.\" Automatically generated by Pandoc 3.3
.\"
.\" **** Custom macro definitions *********************************
.\" * Super/subscript
.\" (https://lists.gnu.org/archive/html/groff/2012-07/msg00046.html)
.ds { \v'-0.3m'\\s[\\n[.s]*9u/12u]
.ds } \s0\v'0.3m'
.ds < \v'0.3m'\s[\\n[.s]*9u/12u]
.ds > \s0\v'-0.3m'
.\" * Horizontal line
.de HLINE
.LP
.ce
\l'20'
..
.\" * Syntax highlighting macros
.defcolor f8f8f8 rgb #f8f8f8
.defcolor aaaaaa rgb #aaaaaa
.defcolor 204a87 rgb #204a87
.defcolor 0000cf rgb #0000cf
.defcolor 8f5902 rgb #8f5902
.defcolor 4e9a06 rgb #4e9a06
.defcolor ce5c00 rgb #ce5c00
.defcolor 000000 rgb #000000
.defcolor ef2929 rgb #ef2929
.defcolor a40000 rgb #a40000
.ds KeywordTok \&\\m[204a87]\\f[CB]\\$1\\f[C]\\m[]
.ds DataTypeTok \&\\m[204a87]\\$1\\m[]
.ds DecValTok \&\\m[0000cf]\\$1\\m[]
.ds BaseNTok \&\\m[0000cf]\\$1\\m[]
.ds FloatTok \&\\m[0000cf]\\$1\\m[]
.ds ConstantTok \&\\m[8f5902]\\$1\\m[]
.ds CharTok \&\\m[4e9a06]\\$1\\m[]
.ds SpecialCharTok \&\\m[ce5c00]\\f[CB]\\$1\\f[C]\\m[]
.ds StringTok \&\\m[4e9a06]\\$1\\m[]
.ds VerbatimStringTok \&\\m[4e9a06]\\$1\\m[]
.ds SpecialStringTok \&\\m[4e9a06]\\$1\\m[]
.ds ImportTok \&\\$1
.ds CommentTok \&\\m[8f5902]\\f[CI]\\$1\\f[C]\\m[]
.ds DocumentationTok \&\\m[8f5902]\\f[CBI]\\$1\\f[C]\\m[]
.ds AnnotationTok \&\\m[8f5902]\\f[CBI]\\$1\\f[C]\\m[]
.ds CommentVarTok \&\\m[8f5902]\\f[CBI]\\$1\\f[C]\\m[]
.ds OtherTok \&\\m[8f5902]\\$1\\m[]
.ds FunctionTok \&\\m[204a87]\\f[CB]\\$1\\f[C]\\m[]
.ds VariableTok \&\\m[000000]\\$1\\m[]
.ds ControlFlowTok \&\\m[204a87]\\f[CB]\\$1\\f[C]\\m[]
.ds OperatorTok \&\\m[ce5c00]\\f[CB]\\$1\\f[C]\\m[]
.ds BuiltInTok \&\\$1
.ds ExtensionTok \&\\$1
.ds PreprocessorTok \&\\m[8f5902]\\f[CI]\\$1\\f[C]\\m[]
.ds AttributeTok \&\\m[204a87]\\$1\\m[]
.ds RegionMarkerTok \&\\$1
.ds InformationTok \&\\m[8f5902]\\f[CBI]\\$1\\f[C]\\m[]
.ds WarningTok \&\\m[8f5902]\\f[CBI]\\$1\\f[C]\\m[]
.ds AlertTok \&\\m[ef2929]\\$1\\m[]
.ds ErrorTok \&\\m[a40000]\\f[CB]\\$1\\f[C]\\m[]
.ds NormalTok \&\\$1
.\" **** Settings *************************************************
.\" text width
.nr LL 16c
.\" left margin
.nr PO 2.5c
.\" top margin
.nr HM 2.5c
.\" bottom margin
.nr FM 1.5c
.\" header/footer width
.nr LT \n[LL]
.\" point size
.nr PS 10p
.\" line height
.nr VS 12p
.\" font family: A, BM, H, HN, N, P, T, ZCM
.\" fam P
.fam P
.\" paragraph indent
.nr PI 0m
.\" interparagraph space
.nr PD 0.4v
.\" footnote width
.nr FL \n[LL]
.\" footnote point size
.nr FPS (\n[PS] - 2000)
.\" color used for strikeout
.defcolor strikecolor rgb 0.7 0.7 0.7
.\" color for links (rgb)
.ds PDFHREF.COLOUR   0.35 0.00 0.60
.\" border for links (default none)
.ds PDFHREF.BORDER   0 0 0
.\" point size difference between heading levels
.nr PSINCR 1p
.\" heading level above which point size no longer changes
.nr GROWPS 2
.\" comment these out if you want a dot after section numbers:
.als SN SN-NO-DOT
.als SN-STYLE SN-NO-DOT
.\" page numbers in footer, centered
.ds CH
.ds CF %
.\" pdf outline fold level
.nr PDFOUTLINE.FOLDLEVEL 3
.\" start out in outline view
.pdfview /PageMode /UseOutlines
.\" ***************************************************************
.\" PDF metadata
.pdfinfo /Title "Putting Fortran\[cq]s object\-related features to practical use"
.pdfinfo /Author "Reinhold Bader (1966\[en]2024)"
.hy
.EQ
delim @@
.EN
.TL
Putting Fortran\[cq]s object\-related features to practical use
.AU
Reinhold Bader (1966\[en]2024)
.AU
.sp 0.5
.ft R
2024
.\" 1 column (use .2C for two column)
.1C
.if t .ds mp \fR|\\h’-0.4m’\\[->]\fP
.LP
This article describes how advanced Fortran language features can be
applied toward object\-based and object\-oriented programming
techniques.
These are, of course, to a significant extent a matter of taste,
personal style and possibly overarching program design considerations,
so should be taken with a pinch of salt.
.PP
Language features from Fortran 95 and later will be used; those from
Fortran 2003 and later will also be shortly described.
They are explained in more detail in e.g., Metcalf, Reid, Cohen and
Bader.\**
.FS
Metcalf, Michael; Reid, John; Cohen, Malcolm; Bader, Reinhold (2023).
\f[I]Modern Fortran Explained.\f[R] Numerical Mathematics and Scientific
Computation.
Oxford University Press.
\c
.pdfhref W -D "https://en.wikipedia.org/wiki/Special:BookSources/978-0-19-887657-1" -A "\c" \
 -- "ISBN 978\-0\-19\-887657\-1"
\&.
.FE
See also \c
.pdfhref W -D "https://en.wikipedia.org/wiki/Fortran_95_language_features" -A "\c" \
 -- "Fortran 95 language features"
\& for the language\[cq]s fundamentals; the prerequisite for
understanding this article is that features explained there are well
understood.
.PP
Boldface will be used where term definitions are introduced.
They are additionally annotated by \[lq](not a Fortran term)\[rq] or
similar if the term is not used in the Fortran standard itself, but is
in general use in the technical literature.
.PP
Compilable and runnable example code is available from an external \c
.pdfhref W -D "https://github.com/reinh-bader/object_fortran" -A "\c" \
 -- "Github repository"
\&.
.NH 1
Object\-based programming techniques
.pdfhref O 1 "\*[SN]  Object-based programming techniques"
.pdfhref M "sec:oop_techniques"
.XS
.pdfhref L -D "sec:oop_techniques" \
 -- "	\*[SN]\~\~Object\-based programming techniques"
.XE
.NH 1
Introduction: Container\-like types
.pdfhref O 1 "\*[SN]  Introduction: Container-like types"
.pdfhref M "introduction-container-like-types"
.XS
.pdfhref L -D "introduction-container-like-types" \
 -- "	\*[SN]\~\~Introduction: Container\-like types"
.XE
.LP
The word \[lq]Container\-like\[rq] is not a Fortran term, but used in
the context of this article to designate types with components whose
size (or type, to be discussed later) is not known when the type is
declared.
For deferred sizing of array objects, this can be achieved by using
either the \f[CR]POINTER\f[R] or the \f[CR]ALLOCATABLE\f[R] attribute
for the component\[cq]s specification.
.PP
The language features and programming techniques will be shown using two
examples introduced in the following section.
The demonstration codes for this chapter can be found in the
\f[CR]object_based\f[R] folder of the \c
.pdfhref W -D "https://github.com/reinh-bader/object_fortran" -A "\c" \
 -- "Github repository"
\&.
.NH 1
Examples for definitions of container\-like types
.pdfhref O 1 "\*[SN]  Examples for definitions of container-like types"
.pdfhref M "examples-for-definitions-of-container-like-types"
.XS
.pdfhref L -D "examples-for-definitions-of-container-like-types" \
 -- "	\*[SN]\~\~Examples for definitions of container\-like types"
.XE
.NH 2
Allocatable components
.pdfhref O 2 "\*[SN]  Allocatable components"
.pdfhref M "allocatable-components"
.XS
.pdfhref L -D "allocatable-components" \
 -- "		\*[SN]\~\~Allocatable components"
.XE
.LP
As an example for the type definition of a \f[B]value container\f[R]
(not a Fortran term) with an \f[CR]ALLOCATABLE\f[R] component consider
.IP
.nf
\f[C]
\*[DataTypeTok "TYPE"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " polynomial"]
\*[NormalTok "   "]\*[DataTypeTok "PRIVATE"]
\*[NormalTok "   "]\*[DataTypeTok "REAL"]\*[NormalTok ", "]\*[DataTypeTok "ALLOCATABLE"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " a(:)"]
\*[DataTypeTok "END TYPE"]
\f[]
.fi
.LP
An object declared to be of this type
.IP
.nf
\f[C]
\*[DataTypeTok "TYPE(polynomial)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " p"]
\f[]
.fi
.LP
is suitable for characterization of a polynomial
.PP
@p left ( x right ) = sum sub {k = 0} sup {roman "degree"} a sub k \[u22C5] x sup k fwd 100 left ( x \[u2208] \[u211C] right )@
.PP
once it has been created and subsequently supplied with values of the
coefficients:
.IP
.nf
\f[C]
\*[NormalTok "degree "]\*[KeywordTok "="]\*[NormalTok " ... "]\*[CommentTok "! integer value known at run time only"]
\*[KeywordTok "ALLOCATE"]\*[NormalTok "( p"]\*[OperatorTok "%"]\*[NormalTok "a("]\*[DecValTok "0"]\*[NormalTok ":degree) )"]
\*[NormalTok "p"]\*[OperatorTok "%"]\*[NormalTok "a("]\*[DecValTok "0"]\*[NormalTok ":) "]\*[KeywordTok "="]\*[NormalTok " ..."]
\f[]
.fi
.NH 2
Pointer components
.pdfhref O 2 "\*[SN]  Pointer components"
.pdfhref M "pointer-components"
.XS
.pdfhref L -D "pointer-components" \
 -- "		\*[SN]\~\~Pointer components"
.XE
.LP
As an example for the type definition of a \f[B]reference container\f[R]
(not a Fortran term) with a \f[CR]POINTER\f[R] component consider
.IP
.nf
\f[C]
\*[DataTypeTok "TYPE"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " sorted_list"]
\*[NormalTok "   "]\*[DataTypeTok "PRIVATE"]
\*[NormalTok "   "]\*[DataTypeTok "TYPE(sortable)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " data"]
\*[NormalTok "   "]\*[DataTypeTok "TYPE(sorted_list)"]\*[NormalTok ", "]\*[DataTypeTok "POINTER"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " next "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " null()"]
\*[DataTypeTok "END TYPE"]
\f[]
.fi
.LP
Note that referencing the type itself when declaring a component is
permitted if that component has the \f[CR]POINTER\f[R] or
\f[CR]ALLOCATABLE\f[R] attribute; such types are generally known as
\f[B]recursive\f[R].
They are used to represent information structures (lists, trees, \&...),
often with specific relationships between the individual data entries
stored in each node.
In this example, the assumption is that entries of type \f[CR]data\f[R]
in subsequent list items fulfill an ordering condition, based on the
functionality supplied with that type:
.IP
.nf
\f[C]
\*[DataTypeTok "TYPE"]\*[NormalTok ", "]\*[DataTypeTok "PUBLIC"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " sortable"]
\*[NormalTok "   "]\*[DataTypeTok "CHARACTER(len=:)"]\*[NormalTok ", "]\*[DataTypeTok "ALLOCATABLE"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " string"]
\*[DataTypeTok "END TYPE"]

\*[KeywordTok "INTERFACE"]\*[NormalTok " "]\*[KeywordTok "OPERATOR"]\*[NormalTok "("]\*[OperatorTok "<"]\*[NormalTok ")          "]\*[CommentTok "! compare two objects of type sortable"]
\*[NormalTok "   "]\*[KeywordTok "MODULE PROCEDURE"]\*[NormalTok " less_than  "]\*[CommentTok "! implementation not shown here"]
\*[KeywordTok "END INTERFACE"]
\f[]
.fi
.LP
\f[I]Hint:\f[R] Given that Fortran supports arrays, use of simple linked
lists is in most cases inappropriate.
The example is presented here as being the simplest that permits
illustrating the language features of interest.
.PP
An object declared to be
.IP
.nf
\f[C]
\*[DataTypeTok "TYPE(sorted_list)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " my_list"]
\f[]
.fi
.LP
is suitable as starting point for building a linked list with node
entries of type \f[CR]data\f[R].
In the simplest case, inserting a data item into the object is done by
executing the following statements:
.IP
.nf
\f[C]
\*[DataTypeTok "TYPE(sortable)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " my_data"]
\*[NormalTok ":"]
\*[NormalTok "my_data "]\*[KeywordTok "="]\*[NormalTok " ..."]
\*[NormalTok "my_list"]\*[OperatorTok "%"]\*[NormalTok "data "]\*[KeywordTok "="]\*[NormalTok " my_data  "]\*[CommentTok "! only compiles if type definition is accessible in host"]
\f[]
.fi
.LP
However, as we shall see below, setting up a complete and valid
\f[CR]sorted_list\f[R] object in a reliable manner needs additional
work.
.NH 1
Constructing objects of container\-like type
.pdfhref O 1 "\*[SN]  Constructing objects of container-like type"
.pdfhref M "constructing-objects-of-container-like-type"
.XS
.pdfhref L -D "constructing-objects-of-container-like-type" \
 -- "	\*[SN]\~\~Constructing objects of container\-like type"
.XE
.LP
The semantics of the default structure constructor for container\-like
objects needs to account for any additional \f[CR]POINTER\f[R] or
\f[CR]ALLOCATABLE\f[R] attribute specified for type components.
.PP
For the first example type from the last section, the executable
statements in
.IP
.nf
\f[C]
\*[DataTypeTok "TYPE(polynomial)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " q, r"]
\*[NormalTok ":"]
\*[NormalTok "q "]\*[KeywordTok "="]\*[NormalTok " polynomial( "]\*[KeywordTok "["]\*[FloatTok "2."]\*[NormalTok ", "]\*[FloatTok "3."]\*[NormalTok ", "]\*[FloatTok "1."]\*[KeywordTok "]"]\*[NormalTok " )"]
\*[NormalTok "r "]\*[KeywordTok "="]\*[NormalTok " polynomial( null() )"]
\f[]
.fi
.LP
result in an object \f[CR]q\f[R] auto\-allocated to the value
\f[CR]q%a(1:3) == [2., 3., 1.]\f[R], and an object \f[CR]r\f[R] with
\f[CR]r%a\f[R] unallocated.
.PP
For the second example type from the last section, the executable
statements in
.IP
.nf
\f[C]
\*[DataTypeTok "TYPE(sorted_list)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " sl1"]
\*[DataTypeTok "TYPE(sorted_list)"]\*[NormalTok ", "]\*[DataTypeTok "target"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " sl2"]
\*[DataTypeTok "TYPE(sortable)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " d1, d2"]
\*[NormalTok ":"]
\*[NormalTok "sl1 "]\*[KeywordTok "="]\*[NormalTok " sorted_list( data"]\*[KeywordTok "="]\*[NormalTok "d1, next"]\*[KeywordTok "="]\*[NormalTok "sl2 )  "]\*[CommentTok "! use keyword notation"]
\*[NormalTok "sl2 "]\*[KeywordTok "="]\*[NormalTok " sorted_list( d2, null() )"]
\f[]
.fi
.LP
result in an object \f[CR]sl1\f[R] with \f[CR]sl1%next\f[R] pointer
associated with \f[CR]sl2\f[R], and an object \f[CR]sl2\f[R] with
\f[CR]sl2%next\f[R] disassociated; the \f[CR]data\f[R] components of
both objects have values, \f[CR]d1\f[R] and \f[CR]d2\f[R], respectively.
Note that an argument that matches with a \f[CR]POINTER\f[R] component
must have either the \f[CR]POINTER\f[R] or the \f[CR]TARGET\f[R]
attribute.
Also, \f[B]keyword notation\f[R] can be used in structure constructors
in the same manner as for procedure arguments.
.PP
The default constructor\[cq]s behaviour has some properties that one
needs to be aware of:
.IP " 1." 4
If all type components have the \f[CR]PRIVATE\f[R] attribute i.e., the
type is \f[B]opaque\f[R] (not a Fortran term), it can only be used if
the type declaration is accessed by host association (this is the same
as for nonallocatable/nonpointer components);
.IP " 2." 4
especially for container\-like types, its semantics may be incompatible
with the programmers intentions for how the objects should be used.
.LP
Item 2 is illustrated by the above object setups, specifically:
.IP \[bu] 3
In the \f[CR]polynomial\f[R] example given above, the lower bound of
\f[CR]q%a\f[R] is set to 1, contrary to the expectation that it should
be 0.
One could account for this by calculating index offsets in any module
procedures that process \f[CR]polynomial\f[R] objects, but this makes
the code harder to understand and maintain.
Also, the degree of the polynomial should be determined by the last
nonzero entry of the coefficient array, but the language can of course
not be aware of this.
.IP \[bu] 3
In the \f[CR]sorted_list\f[R] example given above, the ordering
requirement for entries in subsequent nodes is not checked, so will
usually be not fulfilled.
Also, if \f[CR]sl2\f[R] goes out of scope before \f[CR]sl1\f[R] does,
the list structure is torn to bits.
.LP
The programmer can enforce appropriate semantics by overloading the
structure constructor.
In this case, it is usually a good idea to declare the types as being
opaque.
.PP
Overloading the structure constructor is done by
.IP \[bu] 3
creating a named interface (i.e., a generic function) with the same name
as the type of interest;
.IP \[bu] 3
creating at least one specific function (a subroutine is not permitted),
usually returning a scalar result of the type of interest.
.LP
For the \f[CR]polynomial\f[R] type the interface block (placed in the
specification section of the module containing the type definition)
might read
.IP
.nf
\f[C]
\*[KeywordTok "INTERFACE"]\*[NormalTok " polynomial"]
\*[CommentTok "! overload to assure correct lower bound when creating a polynomial object"]
\*[NormalTok "   "]\*[KeywordTok "MODULE PROCEDURE"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " create_polynomial"]
\*[NormalTok "   ... "]\*[CommentTok "! further specifics as needed"]
\*[KeywordTok "END INTERFACE"]
\f[]
.fi
.LP
and the implementation of \f[CR]create_polynomial\f[R] (in the
\f[CR]CONTAINS\f[R] part of the module) might read
.IP
.nf
\f[C]
\*[KeywordTok "PURE"]\*[NormalTok " "]\*[DataTypeTok "TYPE(polynomial)"]\*[NormalTok " "]\*[KeywordTok "FUNCTION"]\*[NormalTok " create_polynomial(a)"]
\*[NormalTok "   "]\*[DataTypeTok "REAL"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(in)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " a("]\*[DecValTok "0"]\*[NormalTok ":)"]
\*[NormalTok "   "]\*[DataTypeTok "INTEGER"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " degree("]\*[DecValTok "1"]\*[NormalTok ")"]

\*[NormalTok "   degree "]\*[KeywordTok "="]\*[NormalTok " "]\*[FunctionTok "findloc"]\*[NormalTok "( a "]\*[OperatorTok "/="]\*[NormalTok " "]\*[FloatTok "0.0"]\*[NormalTok ", "]\*[DataTypeTok "value"]\*[KeywordTok "="]\*[ConstantTok ".true."]\*[NormalTok ", back"]\*[KeywordTok "="]\*[ConstantTok ".true."]\*[NormalTok " ) "]\*[KeywordTok "\-"]\*[NormalTok " "]\*[DecValTok "1"]
\*[NormalTok "   "]\*[KeywordTok "ALLOCATE"]\*[NormalTok "( create_polynomial"]\*[OperatorTok "%"]\*[NormalTok "a("]\*[DecValTok "0"]\*[NormalTok ":degree("]\*[DecValTok "1"]\*[NormalTok ")) )"]
\*[NormalTok "   create_polynomial"]\*[OperatorTok "%"]\*[NormalTok "a("]\*[DecValTok "0"]\*[NormalTok ":) "]\*[KeywordTok "="]\*[NormalTok " a("]\*[DecValTok "0"]\*[NormalTok ":degree("]\*[DecValTok "1"]\*[NormalTok "))"]
\*[KeywordTok "END FUNCTION"]
\f[]
.fi
.LP
Because its signature matches the default structure constructor\[cq]s,
the function actually overrides the default constructor, making it
generally unavailable.
.PP
For the \f[CR]sorted_list\f[R] type the interface block might read
.IP
.nf
\f[C]
\*[KeywordTok "INTERFACE"]\*[NormalTok " sorted_list"]
\*[CommentTok "! the default constructor is unavailable because the type is opaque"]
\*[CommentTok "! the specific has a different signature than the structure constructor"]
\*[NormalTok "   "]\*[KeywordTok "MODULE PROCEDURE"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " create_sorted_list"]
\*[NormalTok "   ... "]\*[CommentTok "! further specifics as needed"]
\*[KeywordTok "END INTERFACE"]
\f[]
.fi
.LP
with the implementation of \f[CR]create_sorted_list\f[R] as follows:
.IP
.nf
\f[C]
\*[KeywordTok "PURE"]\*[NormalTok " "]\*[KeywordTok "FUNCTION"]\*[NormalTok " create_sorted_list(item_array) "]\*[KeywordTok "RESULT"]\*[NormalTok "(head)"]
\*[NormalTok "   "]\*[DataTypeTok "TYPE(sortable)"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(in)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " item_array(:)"]
\*[NormalTok "   "]\*[DataTypeTok "TYPE(sorted_list)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " head"]
\*[NormalTok "   "]\*[DataTypeTok "INTEGER"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " i"]

\*[NormalTok "   "]\*[KeywordTok "DO"]\*[NormalTok " i "]\*[KeywordTok "="]\*[NormalTok " "]\*[DecValTok "1"]\*[NormalTok ", "]\*[FunctionTok "size"]\*[NormalTok "(item_array)"]
\*[NormalTok "      "]\*[KeywordTok "CALL"]\*[NormalTok " add_to_sorted_list(head, item_array(i))"]
\*[NormalTok "      "]\*[CommentTok "! handles tedious details of pointer fiddling"]
\*[NormalTok "   "]\*[KeywordTok "END DO"]
\*[KeywordTok "END FUNCTION"]
\f[]
.fi
.LP
The constructor has a signature that differs from that of the default
one, but the latter is unavailable outside the host scope of the type
definition anyway, due to the opacity of \f[CR]sorted_list\f[R].
.NH 1
Copying objects of container\-like type
.pdfhref O 1 "\*[SN]  Copying objects of container-like type"
.pdfhref M "copying-objects-of-container-like-type"
.XS
.pdfhref L -D "copying-objects-of-container-like-type" \
 -- "	\*[SN]\~\~Copying objects of container\-like type"
.XE
.LP
Default assignment extends to container\-like objects.
For objects declared as
.IP
.nf
\f[C]
\*[DataTypeTok "TYPE(polynomial)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " p, q"]
\*[DataTypeTok "TYPE(sorted_list)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " slp, slq"]

\*[NormalTok "... "]\*[CommentTok "! code that defines p, slp"]
\f[]
.fi
.LP
and after defining values for prospective right\-hand sides, execution
of the statement
.IP
.nf
\f[C]
\*[NormalTok "q "]\*[KeywordTok "="]\*[NormalTok " p"]
\f[]
.fi
.LP
produces the same result as
.IP
.nf
\f[C]
\*[KeywordTok "IF"]\*[NormalTok " ( "]\*[FunctionTok "allocated"]\*[NormalTok "(q"]\*[OperatorTok "%"]\*[NormalTok "a) ) "]\*[KeywordTok "DEALLOCATE"]\*[NormalTok "( q"]\*[OperatorTok "%"]\*[NormalTok "a )"]
\*[NormalTok "q"]\*[OperatorTok "%"]\*[NormalTok "a "]\*[KeywordTok "="]\*[NormalTok " p"]\*[OperatorTok "%"]\*[NormalTok "a  "]\*[CommentTok "! performs auto\-allocation using the RHS\[aq]s bounds, then copies the value"]
\f[]
.fi
.LP
and execution of the statement
.IP
.nf
\f[C]
\*[NormalTok "slq "]\*[KeywordTok "="]\*[NormalTok " slp"]
\f[]
.fi
.LP
produces the same result as
.IP
.nf
\f[C]
\*[NormalTok "slq"]\*[OperatorTok "%"]\*[NormalTok "data "]\*[KeywordTok "="]\*[NormalTok " slp"]\*[OperatorTok "%"]\*[NormalTok "data"]
\*[NormalTok "slq"]\*[OperatorTok "%"]\*[NormalTok "next "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " slp"]\*[OperatorTok "%"]\*[NormalTok "next  "]\*[CommentTok "! creates a reference between list objects without copying any value"]
\f[]
.fi
.LP
The terms \f[B]deep copy\f[R] and \f[B]shallow copy\f[R] (neither are
Fortran terms) are sometimes used to describe the above behaviour for
\f[CR]ALLOCATABLE\f[R] and \f[CR]POINTER\f[R] components, respectively.
Note that \- different from the default structure constructor \- having
\f[CR]PRIVATE\f[R] components does not affect the use of default
assigment.
However, the semantics of default assignment might not be what is needed
from the programmer\[cq]s point of view.
.PP
Specifically, consider the case where the object \f[CR]slq\f[R] above
has previously been set up by invoking the overloaded constructor.
The assignment above would then have the following effects:
.IP " 1." 4
The list elements of the original \f[CR]slq\f[R], beginning with
\f[CR]slq%next\f[R], would become inaccessible (\[lq]orphaned\[rq]),
effectively causing a memory leak;
.IP " 2." 4
after the assignment statement, \f[CR]slq%next\f[R] references into
\f[CR]slp%next\f[R], resulting in aliasing.
.LP
To avoid 2., it is possible to \c
.pdfhref W -D "https://en.wikipedia.org/wiki/Fortran_95_language_features#Derived-data_types" -A "\c" \
 -- "\f[B]overload\f[R] the assignment operator"
\& for reference containers to create a deep copy.
Note that in the case where defined unary or binary operations are
introduced, the functions that define these need to create deep copies
to create the result variable anyway, otherwise things simply don\[cq]t
work.
The downside of this is that in code like
.IP
.nf
\f[C]
\*[NormalTok "slq "]\*[KeywordTok "="]\*[NormalTok " slp "]\*[KeywordTok "//"]\*[NormalTok " slq"]
\f[]
.fi
.LP
\ \[en] with the overloaded concatenation operator meaning that the
argument lists are joined \[en] multiple deep copies need to be done
(the implementation of the module procedure \f[CR]join_lists\f[R] that
supplies the necessary specific for \f[CR]//\f[R] is not shown here; see
the source \f[CR]code sorted_list.f90\f[R] for details).
It turns out that some of these exist only intermediately.
.PP
Here an implementation of the specific procedure for the overloaded
assignment of \f[CR]sorted_list\f[R] objects:
.IP
.nf
\f[C]
\*[KeywordTok "SUBROUTINE"]\*[NormalTok " assign_sorted_list("]\*[KeywordTok "to"]\*[NormalTok ", from)"]
\*[NormalTok "   "]\*[DataTypeTok "TYPE(sorted_list)"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(in)"]\*[NormalTok ", "]\*[DataTypeTok "TARGET"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " from"]
\*[NormalTok "   "]\*[DataTypeTok "TYPE(sorted_list)"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(out)"]\*[NormalTok ", "]\*[DataTypeTok "TARGET"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " "]\*[KeywordTok "to"]\*[NormalTok "  "]\*[CommentTok "! finalizer is executed on entry,"]
\*[NormalTok "                                                 "]\*[CommentTok "! see below for discussion of this."]
\*[NormalTok "   "]\*[DataTypeTok "TYPE(sorted_list)"]\*[NormalTok ", "]\*[DataTypeTok "POINTER"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " p, q"]

\*[NormalTok "   p "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " from; q "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " "]\*[KeywordTok "to"]

\*[NormalTok "   deep_copy : "]\*[KeywordTok "DO"]
\*[NormalTok "      "]\*[KeywordTok "IF"]\*[NormalTok " ( "]\*[FunctionTok "associated"]\*[NormalTok "(p) ) "]\*[KeywordTok "THEN"]
\*[NormalTok "         q"]\*[OperatorTok "%"]\*[NormalTok "data "]\*[KeywordTok "="]\*[NormalTok " p"]\*[OperatorTok "%"]\*[NormalTok "data"]
\*[NormalTok "      "]\*[KeywordTok "ELSE"]
\*[NormalTok "         "]\*[KeywordTok "EXIT"]\*[NormalTok " deep_copy"]
\*[NormalTok "      "]\*[KeywordTok "END IF"]
\*[NormalTok "      p "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " p"]\*[OperatorTok "%"]\*[NormalTok "next"]
\*[NormalTok "      "]\*[KeywordTok "IF"]\*[NormalTok " ( "]\*[FunctionTok "associated"]\*[NormalTok "(p) ) "]\*[KeywordTok "ALLOCATE"]\*[NormalTok "( q"]\*[OperatorTok "%"]\*[NormalTok "next )"]
\*[NormalTok "      q "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " q"]\*[OperatorTok "%"]\*[NormalTok "next"]
\*[NormalTok "   "]\*[KeywordTok "END DO"]\*[NormalTok " deep_copy"]
\*[KeywordTok "END SUBROUTINE"]
\f[]
.fi
.LP
Avoiding 1.
is usually done by means of finalizers, to be discussed in the next
section.
This is because assignment is not the only possible cause for orphaning
of \f[CR]POINTER\f[R]\-related memory (or indeed other resource leaks).
.NH 1
Finalization and conclusions
.pdfhref O 1 "\*[SN]  Finalization and conclusions"
.pdfhref M "finalization-and-conclusions"
.XS
.pdfhref L -D "finalization-and-conclusions" \
 -- "	\*[SN]\~\~Finalization and conclusions"
.XE
.LP
To deal with resource leaks that are otherwise not within the
programmer\[cq]s means to avoid, a type definition can be connected with
a user\-defined \f[B]final procedure\f[R] that is automatically invoked
in certain situations.
For the \f[CR]sorted_list\f[R] type, this would look like
.IP
.nf
\f[C]
\*[DataTypeTok "TYPE"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " sorted_list"]
\*[NormalTok "   "]\*[DataTypeTok "PRIVATE"]
\*[NormalTok "   "]\*[DataTypeTok "TYPE(sortable)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " data"]
\*[NormalTok "   "]\*[DataTypeTok "TYPE(sorted_list)"]\*[NormalTok ", "]\*[DataTypeTok "POINTER"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " next "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " null()"]
\*[KeywordTok "CONTAINS"]
\*[NormalTok "   "]\*[DataTypeTok "FINAL"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " delete_sorted_list"]
\*[DataTypeTok "END TYPE"]
\f[]
.fi
.LP
Note that the \f[CR]FINAL\f[R] statement appears after a
\f[CR]CONTAINS\f[R] statement in the type definition; this implies that
\f[CR]delete_sorted_list\f[R] is not a regular type component.
The module procedure\[cq]s implementation might then be as follows:
.IP
.nf
\f[C]
\*[KeywordTok "PURE"]\*[NormalTok " "]\*[KeywordTok "RECURSIVE"]\*[NormalTok " "]\*[KeywordTok "SUBROUTINE"]\*[NormalTok " delete_sorted_list(list)"]
\*[NormalTok "   "]\*[DataTypeTok "TYPE(sorted_list)"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(inout)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " list"]

\*[NormalTok "   "]\*[KeywordTok "IF"]\*[NormalTok " ( "]\*[FunctionTok "associated"]\*[NormalTok "(list"]\*[OperatorTok "%"]\*[NormalTok "next) ) "]\*[KeywordTok "THEN"]
\*[NormalTok "      "]\*[KeywordTok "DEALLOCATE"]\*[NormalTok "( list"]\*[OperatorTok "%"]\*[NormalTok "next )  "]\*[CommentTok "! invokes the finalizer recursively"]
\*[NormalTok "   "]\*[KeywordTok "END IF"]
\*[KeywordTok "END SUBROUTINE"]
\f[]
.fi
.LP
It must be a subroutine that takes a single argument of the type to be
finalized.
Most additional attributes are not permitted for that dummy argument;
for the case of finalizing array arguments it is possible to have a set
of finalizers (all listed in the type definition), each of which
declares the dummy argument with an appropriate rank.
.PP
\f[I]Hint:\f[R] The \f[CR]PURE\f[R] and \f[CR]RECURSIVE\f[R] properties
specified above reflect the specific needs for the
\f[CR]sorted_list\f[R] type and its associated procedures.
The \f[CR]RECURSIVE\f[R] specification is optional (i.e., procedures can
be called recursively by default), but a \f[CR]NON_RECURSIVE\f[R]
specification can be supplied if the implementation\[cq]s semantics does
not permit correct behaviour in recursive calls.
.PP
The finalizer will be automatically invoked on an object if
.IP " 1." 4
it appears on the left\-hand side of an intrinsic assignment statement
(before the assignment is performed),
.IP " 2." 4
on invocation of a procedure call where it is argument associated with
an \f[CR]INTENT(out)\f[R] dummy,
.IP " 3." 4
it is a non\-saved variable and program execution ends its scope, or
.IP " 4." 4
it is deallocated.
.LP
Nonpointer nonallocatable function results fall into the third category
above; however, finalization does not apply for the default structure
constructor.
.PP
Note that if a finalizer is defined and the constructor is overloaded,
but the assignment operator is \f[I]not\f[R], then the assignment
statement \f[CR]slq = sorted_list(...)\f[R] (which then translates into
a single function call to the \f[CR]create_sorted_list()\f[R] function
shown earlier) will result in a mutilated left\-hand side, because the
finalizer will be executed on the function that overloads the
constructor, resulting in \f[CR]slq%next\f[R] being disassociated.
For this reason, the following guideline applies:
.QS
.LP
Recommendation:
.br
Finalizers, overloads for the default constructor, and overload of the
assignment operation should usually be jointly implemented.
.QE
.LP
See also the article \[lq]\c
.pdfhref W -D "https://en.wikipedia.org/wiki/Rule_of_three_(C%2B%2B_programming)" -A "\c" \
 -- "Rule of three"
\&\[rq] for the analogous situation in C++.
.NH 1
Further language features useful for object\-based programming
.pdfhref O 1 "\*[SN]  Further language features useful for object-based programming"
.pdfhref M "further-language-features-useful-for-object-based-programming"
.XS
.pdfhref L -D "further-language-features-useful-for-object-based-programming" \
 -- "	\*[SN]\~\~Further language features useful for object\-based programming"
.XE
.NH 2
Extended semantics for allocatable objects
.pdfhref O 2 "\*[SN]  Extended semantics for allocatable objects"
.pdfhref M "extended-semantics-for-allocatable-objects"
.XS
.pdfhref L -D "extended-semantics-for-allocatable-objects" \
 -- "		\*[SN]\~\~Extended semantics for allocatable objects"
.XE
.LP
Scalars can have the \f[CR]ALLOCATABLE\f[R] attribute:
.IP
.nf
\f[C]
\*[DataTypeTok "CHARACTER(len=:)"]\*[NormalTok ", "]\*[DataTypeTok "ALLOCATABLE"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " my_string"]
\*[DataTypeTok "TYPE(sorted_list)"]\*[NormalTok ", "]\*[DataTypeTok "ALLOCATABLE"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " my_list"]
\f[]
.fi
.LP
Allocation then can be done explicitly; the following examples
illustrate applications of the \f[CR]ALLOCATE\f[R] statement that are
useful or even necessary in this context:
.IP
.nf
\f[C]
\*[KeywordTok "ALLOCATE"]\*[NormalTok "( "]\*[DataTypeTok "CHARACTER(len=13)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " my_string )                  "]\*[CommentTok "! typed allocation"]
\*[KeywordTok "ALLOCATE"]\*[NormalTok "( my_list, source"]\*[KeywordTok "="]\*[NormalTok "sorted_list(array_of_sortable) )  "]\*[CommentTok "! sourced allocation"]
\f[]
.fi
.LP
\f[B]Typed allocation\f[R] is necessary for the string variable, because
the length parameter of a string is part of its type; we will later see
that derived types can also appear in the type specification.
\f[B]Sourced allocation\f[R] permits the creation of an allocated object
that is a clone of the specified source object or expression.
.PP
Alternatively, allocatable objects (be they scalar or arrays) can be
auto\-allocated by appearing on the left\-hand side of an
\f[I]intrinsic\f[R] assignment statement:
.IP
.nf
\f[C]
\*[NormalTok "my_string "]\*[KeywordTok "="]\*[NormalTok " "]\*[StringTok "\[dq]anything goes\[dq]"]\*[NormalTok "  "]\*[CommentTok "! auto\-allocated to RHS length before value is transferred"]
\*[CommentTok "! my_list = sorted_list(array_of_sortable)"]
\*[CommentTok "! the above statement would fail for an unallocated object, because the assignment"]
\*[CommentTok "! has been overloaded using a nonallocatable first dummy argument"]
\f[]
.fi
.LP
A caveat is that for \f[I]overloaded\f[R] assignment, this will usually
not work \- either one needs to explicitly allocate the object before
assigning to it, or sourced allocation must be used, which bypasses the
overloaded assignment.
.PP
Note that for allocatable objects with deferred\-size entries (e.g.,
strings, arrays) a non\-conformable left\-hand side in an assignment
statement will be deallocated before being allocated to the right length
or shape, respectively.
.PP
\f[I]Hint:\f[R] The features discussed in this subsection are also
useful for object\-oriented programming, with additional semantics
applying for the case of polymorphic objects.
.NH 2
Implementing move semantics
.pdfhref O 2 "\*[SN]  Implementing move semantics"
.pdfhref M "implementing-move-semantics"
.XS
.pdfhref L -D "implementing-move-semantics" \
 -- "		\*[SN]\~\~Implementing move semantics"
.XE
.LP
Sometimes it may be necessary to make use of move instead of copy
semantics i.e., create a copy of an object and then getting rid of the
original.
The simplest way of doing this is to make use of allocatable (scalar or
array) objects,
.IP
.nf
\f[C]
\*[DataTypeTok "TYPE(sorted_list)"]\*[NormalTok ", "]\*[DataTypeTok "ALLOCATABLE"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " my_list, your_list"]
\f[]
.fi
.LP
After \f[CR]your_list\f[R] has been set up, the object\[cq]s content can
then be transferred to \f[CR]my_list\f[R] by using the
\f[CR]move_alloc\f[R] intrinsic,
.IP
.nf
\f[C]
\*[KeywordTok "CALL"]\*[NormalTok " move_alloc(your_list, my_list)"]
\f[]
.fi
.LP
which will deallocate \f[CR]my_list\f[R] if necessary, before doing the
transfer.
After the invocation, \f[CR]my_list\f[R] will have the value formerly
stored in \f[CR]your_list\f[R], and \f[CR]your_list\f[R] will end up in
the deallocated state.
Note that the latter does not involve a regular object deallocation
(effectively, a descriptor for the object is moved), so any existing
finalizer will not be invoked.
.NH 2
The \f[CB]BLOCK\f[B] construct
.pdfhref O 2 "\*[SN]  The BLOCK construct"
.pdfhref M "the-block-construct"
.XS
.pdfhref L -D "the-block-construct" \
 -- "		\*[SN]\~\~The \f[CB]BLOCK\f[B] construct"
.XE
.LP
The above rules on finalization imply that variables declared in the
specification part of the main program are not finalizable, since they
by default have the \f[CR]SAVE\f[R] attribute.
One could argue this is not necessary since all assigned memory is
reclaimed when program execution ends.
However, excessive memory consumption or the use of other resources may
cause issues for reliable program execution.
To work around these, the \f[CR]BLOCK\f[R] construct can be used:
.IP
.nf
\f[C]
\*[KeywordTok "PROGRAM"]\*[NormalTok " test_sorted_list"]
\*[NormalTok "   "]\*[KeywordTok "USE"]\*[NormalTok " mod_sortable"]
\*[NormalTok "   "]\*[KeywordTok "USE"]\*[NormalTok " mod_sorted_list"]
\*[NormalTok "   "]\*[KeywordTok "IMPLICIT"]\*[NormalTok " "]\*[KeywordTok "none"]
\*[NormalTok "   :"]
\*[NormalTok "   work : "]\*[KeywordTok "BLOCK"]
\*[NormalTok "      "]\*[DataTypeTok "TYPE(sortable)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " array(items)"]
\*[NormalTok "      "]\*[DataTypeTok "TYPE(sorted_list)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " my_list, ..."]
\*[NormalTok "      : "]\*[CommentTok "! initialize array"]

\*[NormalTok "      my_list "]\*[KeywordTok "="]\*[NormalTok " sorted_list(array)"]
\*[NormalTok "      :"]
\*[NormalTok "   "]\*[KeywordTok "END BLOCK"]\*[NormalTok " work  "]\*[CommentTok "! finalizer is executed on my_list, ..."]
\*[NormalTok "   :"]
\*[KeywordTok "END PROGRAM"]
\f[]
.fi
.LP
The construct (as the only one in Fortran) permits declaration of
non\-saved variables in its specification part.
Their lifetime ends when program execution reaches the
\f[CR]END BLOCK\f[R] statement, and they therefore are finalized at this
point, if applicable.
Named variables declared outside the construct are accessible inside it,
unless a block\-local declaration with the same name exists.
.PP
\f[I]Hint:\f[R] Note that the construct\[cq]s execution flow can be
modified by executing an \f[CR]EXIT\f[R] statement in its body; this
can, for example, be used for structured error handling and finally
permits sending \f[CR]GO TO\f[R] to retirement.
.NH 2
The \f[CB]ASSOCIATE\f[B] construct
.pdfhref O 2 "\*[SN]  The ASSOCIATE construct"
.pdfhref M "the-associate-construct"
.XS
.pdfhref L -D "the-associate-construct" \
 -- "		\*[SN]\~\~The \f[CB]ASSOCIATE\f[B] construct"
.XE
.LP
With the introduction of deeply nested derived types, code that needs
access to ultimate components can become quite hard to read.
An \f[CR]ASSOCIATE\f[R] block construct that enables the use of
auto\-typed aliases can be used.
This is illustrated by a procedure that is used to implement the
multiplication of two polynomials:
.IP
.nf
\f[C]
\*[KeywordTok "PURE"]\*[NormalTok " "]\*[DataTypeTok "TYPE(polynomial)"]\*[NormalTok " "]\*[KeywordTok "FUNCTION"]\*[NormalTok " multiply_polynomial(p1, p2)"]
\*[NormalTok "   "]\*[DataTypeTok "TYPE(polynomial)"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(in)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " p1, p2"]
\*[NormalTok "   "]\*[DataTypeTok "INTEGER"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " j, l, lmax"]

\*[NormalTok "   lmax "]\*[KeywordTok "="]\*[NormalTok " "]\*[FunctionTok "ubound"]\*[NormalTok "(p1"]\*[OperatorTok "%"]\*[NormalTok "a,"]\*[DecValTok "1"]\*[NormalTok ") "]\*[KeywordTok "+"]\*[NormalTok " "]\*[FunctionTok "ubound"]\*[NormalTok "(p2"]\*[OperatorTok "%"]\*[NormalTok "a,"]\*[DecValTok "1"]\*[NormalTok ")"]
\*[NormalTok "   "]\*[KeywordTok "ALLOCATE"]\*[NormalTok "( multiply_polynomial"]\*[OperatorTok "%"]\*[NormalTok "a("]\*[DecValTok "0"]\*[NormalTok ":lmax) )"]

\*[NormalTok "   "]\*[KeywordTok "ASSOCIATE"]\*[NormalTok "( a "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " p1"]\*[OperatorTok "%"]\*[NormalTok "a, b "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " p2"]\*[OperatorTok "%"]\*[NormalTok "a, c "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " multiply_polynomial"]\*[OperatorTok "%"]\*[NormalTok "a, "]\*[KeywordTok "&"]
\*[NormalTok "              jmax "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " "]\*[FunctionTok "ubound"]\*[NormalTok "(p1"]\*[OperatorTok "%"]\*[NormalTok "a,"]\*[DecValTok "1"]\*[NormalTok "), kmax "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " "]\*[FunctionTok "ubound"]\*[NormalTok "(p2"]\*[OperatorTok "%"]\*[NormalTok "a,"]\*[DecValTok "1"]\*[NormalTok ") )  "]\*[CommentTok "! association list"]
\*[NormalTok "      "]\*[KeywordTok "DO"]\*[NormalTok " l "]\*[KeywordTok "="]\*[NormalTok " "]\*[DecValTok "0"]\*[NormalTok ", lmax"]
\*[NormalTok "         c(l) "]\*[KeywordTok "="]\*[NormalTok " "]\*[DecValTok "0"]
\*[NormalTok "         "]\*[KeywordTok "DO"]\*[NormalTok " j "]\*[KeywordTok "="]\*[NormalTok " "]\*[BuiltInTok "max"]\*[NormalTok "("]\*[DecValTok "0"]\*[NormalTok ", l"]\*[KeywordTok "\-"]\*[NormalTok "kmax), "]\*[BuiltInTok "min"]\*[NormalTok "(jmax, l)"]
\*[NormalTok "            c(l) "]\*[KeywordTok "="]\*[NormalTok " c(l) "]\*[KeywordTok "+"]\*[NormalTok " a(j) "]\*[KeywordTok "*"]\*[NormalTok " b(l"]\*[KeywordTok "\-"]\*[NormalTok "j)"]
\*[NormalTok "         "]\*[KeywordTok "END DO"]
\*[NormalTok "      "]\*[KeywordTok "END DO"]
\*[NormalTok "   "]\*[KeywordTok "END ASSOCIATE"]
\*[KeywordTok "END FUNCTION"]
\f[]
.fi
.LP
For the duration of execution of the construct, the associate names can
be used to refer to their selectors (i.e., the right\-hand sides in the
association list).
If the selectors are variables, so are the associate names
(\f[CR]a\f[R], \f[CR]b\f[R], \f[CR]c\f[R] in the above example), and can
be assigned to.
If the selectors are expressions, so are the associate names
(\f[CR]jmax\f[R], \f[CR]kmax\f[R] in the above example).
.PP
Associated entities that refer to variables inherit the
\f[CR]DIMENSION\f[R], \f[CR]CODIMENSION\f[R], \f[CR]TARGET\f[R],
\f[CR]ASYNCHRONOUS\f[R] and \f[CR]VOLATILE\f[R] attributes from their
selectors, but no others.
An associate name can only refer to an \f[CR]OPTIONAL\f[R] dummy
argument if the latter is present.
Associate names can also appear in other block constructs
(\f[CR]SELECT TYPE\f[R], \f[CR]CHANGE TEAM\f[R]), which will be
discussed where appropriate.
.NH 1
Performing I/O with objects of container\-like type
.pdfhref O 1 "\*[SN]  Performing I/O with objects of container-like type"
.pdfhref M "performing-io-with-objects-of-container-like-type"
.XS
.pdfhref L -D "performing-io-with-objects-of-container-like-type" \
 -- "	\*[SN]\~\~Performing I/O with objects of container\-like type"
.XE
.LP
For objects of container\-like type, a data transfer statement
.IP
.nf
\f[C]
\*[DataTypeTok "TYPE(sorted_list)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " my_list"]
\*[NormalTok ": "]\*[CommentTok "! set up my_list"]
\*[FunctionTok "WRITE(*"]\*[NormalTok ", "]\*[FunctionTok "*)"]\*[NormalTok " my_list"]
\f[]
.fi
.LP
would fail to compile, since the run\-time library is incapable of
dealing with the irregular structures that are hiding behind the
innocuous variable.
Language features for user\-defined derived type I/O (\f[B]UDDTIO\f[R])
permit the programmer to control the data transfer in an appropriate
manner.
This is achieved by binding an I/O statement on a derived\-type object
to a user\-defined procedure, for example through a suitably written
named interface:
.IP
.nf
\f[C]
\*[KeywordTok "INTERFACE"]\*[NormalTok " "]\*[FunctionTok "WRITE(formatted)"]
\*[NormalTok "   "]\*[KeywordTok "MODULE PROCEDURE"]\*[NormalTok " write_fmt_list"]
\*[KeywordTok "END INTERFACE"]
\f[]
.fi
.LP
Note that this also applies to data types for which the above
stand\-alone statement is permitted, and then overloads the default I/O
mechanism.
.PP
Once the binding is properly defined, the above I/O statement is
accepted by the compiler, and its execution causes the user\-defined
procedure to be invoked.
Therefore it is called the \f[B]parent\f[R] I/O statement.
The actual data transfer statements that are issued inside the
user\-defined procedure are called \f[B]child\f[R] I/O statements.
.PP
The following interface variants are permitted, with the obvious
interpretation:
.IP \[bu] 3
\f[CR]WRITE(formatted)\f[R]
.IP \[bu] 3
\f[CR]READ(formatted)\f[R]
.IP \[bu] 3
\f[CR]WRITE(unformatted)\f[R]
.IP \[bu] 3
\f[CR]READ(unformatted)\f[R]
.LP
The self\-defined procedure is restricted with respect to its
interfaces\[cq] characteristics, which are described in the following:
.IP
.nf
\f[C]
\*[KeywordTok "SUBROUTINE"]\*[NormalTok " "]\*[OperatorTok "<"]\*[NormalTok "formatted_io"]\*[OperatorTok ">"]\*[NormalTok "   (dtv, unit, iotype, v_list, iostat, iomsg)"]
\*[KeywordTok "SUBROUTINE"]\*[NormalTok " "]\*[OperatorTok "<"]\*[NormalTok "unformatted_io"]\*[OperatorTok ">"]\*[NormalTok " (dtv, unit,                 iostat, iomsg)"]
\f[]
.fi
.LP
The placeholders \f[CR]<formatted_io>\f[R] and
\f[CR]<unformatted_io>\f[R] must be replaced by a specific procedure
name referenced in the generic interface.
.PP
The dummy arguments\[cq] declarations and meaning are:
.IP \[bu] 3
\f[CR]dtv\f[R]: Must be declared to be a nonpointer nonallocatable
scalar of the type in question.
If the type is extensible (to be explained later), the declaration must
be polymorphic (i.e.\ using \f[CR]CLASS\f[R]), otherwise
non\-polymorphic (using \f[CR]TYPE\f[R]).
Its \f[CR]INTENT\f[R] must be \f[CR]in\f[R] for \f[CR]WRITE(...)\f[R],
and \[lq]\f[CR]out\f[R]\[rq] or \[lq]\f[CR]inout\f[R]\[rq] for
\f[CR]READ(...)\f[R].
It represents the object on which data transfer statements are to be
executed.
.RS 3
.PP
\f[I]Hint:\f[R] Note: For the examples in this chapter, we need to use
\f[CR]CLASS\f[R], but the behaviour is as if \f[CR]TYPE\f[R] were used,
as long as the actual arguments are non\-polymorphic and the
procedure\-based interface is used for the invocation.
.RE
.IP \[bu] 3
\f[CR]unit\f[R]: An \f[CR]INTEGER\f[R] scalar with
\f[CR]INTENT(in)\f[R].
Its value is that of the unit used for data transfer statements.
Use of other unit values is not permitted (except, perhaps,
\f[CR]error_unit\f[R] for debugging purposes).
.IP \[bu] 3
\f[CR]iotype\f[R]: A \f[CR]CHARACTER(len=*)\f[R] string with
\f[CR]INTENT(in)\f[R].
This can only appear in procedures for formatted I/O.
The following table describes how the incoming value relates to the
parent I/O transfer statement:
.PP
.na
.nr LLold \n[LL]
.TS
delim(@@) tab(	);
lw(25n) lw(64.5n).
T{
Value
T}	T{
Caused by parent I/O statement
T}
_
T{
.nr LL 20.0n
\f[CR]\[dq]LISTDIRECTED\[dq]\f[R]
T}	T{
.nr LL 50.0n
\f[CR]WRITE(unit, fmt=*) my_list\f[R]
T}
T{
.nr LL 20.0n
\f[CR]\[dq]NAMELIST\[dq]\f[R]
T}	T{
.nr LL 50.0n
\f[CR]WRITE(unit, nml=my_namelist)\f[R] \f[B]Note:\f[R] Referring to the
example, at least one \f[CR]sorted_list\f[R] object must be a member of
\f[CR]my_namelist\f[R].
T}
T{
.nr LL 20.0n
\f[CR]\[dq]DTsorted_list_fmt\[dq]\f[R]
T}	T{
.nr LL 50.0n
\f[CR]WRITE(unit, fmt=\[aq](DT\[dq]sorted_list_fmt\[dq](10,2))\[aq]) my_list\f[R]
\f[B]Note:\f[R] \f[CR]DT\f[R] is the \[lq]derived type\[rq] edit
descriptor that is needed in format\-driven editing to trigger execution
of the UDDTIO routine.
The string following the \f[CR]DT\f[R] edit descriptor can be freely
chosen (even to be zero length); it is recommended that the UDDTIO
procedure pay attention to any possible values supplied in the parent
I/O statement if it supports DT editing.
T}
.TE
.nr LL \n[LLold]
.ad
.IP \[bu] 3
\f[CR]v_list\f[R]: A rank\-1 assumed\-shape \f[CR]INTEGER\f[R] array
with \f[CR]INTENT(in)\f[R] .
This can only appear in procedures for formatted I/O.
The incoming value is taken from the final part of the \f[CR]DT\f[R]
edit descriptor; in the example from the table above it would have the
value \f[CR][10,2]\f[R].
Free use can be made of the value for the disposition (formatting,
controlling) of I/O transfer statements inside the procedure.
The array\[cq]s size may be zero; specifically, it will be of size zero
for the listdirected or namelist cases.
.IP \[bu] 3
\f[CR]iostat\f[R]: An \f[CR]INTEGER\f[R] scalar with
\f[CR]INTENT(out)\f[R].
It must be given a value consistent with those produced by non\-UDTTIO
statements in case of an error.
Successful execution of the I/O must result in a zero value.
Unsuccessful execution must result in either a positive value, or one of
the values \f[CR]iostat_end\f[R] or \f[CR]iostat_eor\f[R] from the
\f[CR]iso_fortran_env\f[R] intrinsic module.
.IP \[bu] 3
\f[CR]iomsg\f[R]: A \f[CR]CHARACTER(len=*)\f[R] string with
\f[CR]INTENT(inout)\f[R].
It must be given a value if a non\-zero \f[CR]iostat\f[R] is returned.
.LP
Additional properties and restrictions for UDDTIO are:
.IP \[bu] 3
All data transfers are executed in non\-advancing mode.
Any \f[CR]advance=\f[R] specifier will be ignored;
.IP \[bu] 3
asynchronous I/O is not supported;
.IP \[bu] 3
Inside the user\-defined routine, no file positioning statements are
permitted.
.LP
The following demonstrates a partial implementation of formatted writing
on \f[CR]sorted_list\f[R] objects:
.IP
.nf
\f[C]
\*[KeywordTok "RECURSIVE"]\*[NormalTok " "]\*[KeywordTok "SUBROUTINE"]\*[NormalTok " write_fmt_list(dtv, unit, iotype, v_list, iostat, iomsg)"]
\*[NormalTok "   "]\*[DataTypeTok "CLASS(sorted_list)"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(in)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " dtv"]
\*[NormalTok "   "]\*[DataTypeTok "INTEGER"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(in)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " unit, v_list(:)"]
\*[NormalTok "   "]\*[DataTypeTok "CHARACTER(len=*)"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(in)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " iotype"]
\*[NormalTok "   "]\*[DataTypeTok "INTEGER"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(out)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " iostat"]
\*[NormalTok "   "]\*[DataTypeTok "CHARACTER(len=*)"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(inout)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " iomsg"]
\*[NormalTok "   "]\*[DataTypeTok "CHARACTER(len=2)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " next_component"]

\*[NormalTok "   "]\*[KeywordTok "IF"]\*[NormalTok " ( "]\*[FunctionTok "associated"]\*[NormalTok "(dtv"]\*[OperatorTok "%"]\*[NormalTok "next) ) "]\*[KeywordTok "THEN"]
\*[NormalTok "      "]\*[FunctionTok "WRITE("]\*[NormalTok "next_component, "]\*[FunctionTok "fmt"]\*[KeywordTok "="]\*[StringTok "\[aq](\[dq]T,\[dq])\[aq]"]\*[FunctionTok ")"]
\*[NormalTok "   "]\*[KeywordTok "ELSE"]
\*[NormalTok "      "]\*[FunctionTok "WRITE("]\*[NormalTok "next_component, "]\*[FunctionTok "fmt"]\*[KeywordTok "="]\*[StringTok "\[aq](\[dq]F\[dq])\[aq]"]\*[FunctionTok ")"]
\*[NormalTok "   "]\*[KeywordTok "END IF"]
\*[NormalTok "   "]\*[KeywordTok "SELECT CASE"]\*[NormalTok " (iotype)"]
\*[NormalTok "   "]\*[KeywordTok "CASE"]\*[NormalTok " ("]\*[StringTok "\[aq]LISTDIRECTED\[aq]"]\*[NormalTok ")"]
\*[NormalTok "      "]\*[FunctionTok "WRITE(unit"]\*[NormalTok ", "]\*[FunctionTok "fmt"]\*[KeywordTok "="]\*[FunctionTok "*"]\*[NormalTok ", "]\*[FunctionTok "delim"]\*[KeywordTok "="]\*[StringTok "\[aq]quote\[aq]"]\*[NormalTok ", "]\*[FunctionTok "iostat"]\*[KeywordTok "="]\*[FunctionTok "iostat"]\*[NormalTok ", iomsg"]\*[KeywordTok "="]\*[NormalTok "iomsg"]\*[FunctionTok ")"]\*[NormalTok " "]\*[KeywordTok "&"]
\*[NormalTok "            dtv"]\*[OperatorTok "%"]\*[NormalTok "data"]\*[OperatorTok "%"]\*[NormalTok "string"]
\*[NormalTok "   "]\*[KeywordTok "CASE"]\*[NormalTok " ("]\*[StringTok "\[aq]NAMELIST\[aq]"]\*[NormalTok ")"]
\*[NormalTok "      "]\*[FunctionTok "WRITE(unit"]\*[NormalTok ", "]\*[FunctionTok "fmt"]\*[KeywordTok "="]\*[FunctionTok "*"]\*[NormalTok ", "]\*[FunctionTok "iostat"]\*[KeywordTok "="]\*[FunctionTok "iostat"]\*[NormalTok ", iomsg"]\*[KeywordTok "="]\*[NormalTok "iomsg"]\*[FunctionTok ")"]\*[NormalTok " "]\*[StringTok "\[aq]\[dq]\[aq]"]\*[NormalTok ", "]\*[KeywordTok "&"]
\*[NormalTok "            dtv"]\*[OperatorTok "%"]\*[NormalTok "data"]\*[OperatorTok "%"]\*[NormalTok "string, "]\*[StringTok "\[aq]\[dq],\[aq]"]\*[NormalTok ", "]\*[FunctionTok "trim"]\*[NormalTok "(next_component)"]
\*[NormalTok "   "]\*[KeywordTok "CASE default"]
\*[NormalTok "      iostat "]\*[KeywordTok "="]\*[NormalTok " "]\*[DecValTok "129"]
\*[NormalTok "      iomsg "]\*[KeywordTok "="]\*[NormalTok " "]\*[StringTok "\[aq]iotype \[aq]"]\*[NormalTok " "]\*[KeywordTok "//"]\*[NormalTok " "]\*[FunctionTok "trim"]\*[NormalTok "(iotype) "]\*[KeywordTok "//"]\*[NormalTok " "]\*[StringTok "\[aq] not implemented\[aq]"]
\*[NormalTok "      "]\*[KeywordTok "RETURN"]
\*[NormalTok "   "]\*[KeywordTok "END SELECT"]
\*[NormalTok "   "]\*[KeywordTok "IF"]\*[NormalTok " ( "]\*[FunctionTok "associated"]\*[NormalTok "(dtv"]\*[OperatorTok "%"]\*[NormalTok "next) ) "]\*[KeywordTok "THEN"]
\*[NormalTok "      "]\*[KeywordTok "CALL"]\*[NormalTok " write_fmt_list(dtv"]\*[OperatorTok "%"]\*[NormalTok "next, unit, iotype, v_list, iostat, iomsg)"]
\*[NormalTok "   "]\*[KeywordTok "END IF"]
\*[KeywordTok "END SUBROUTINE"]
\f[]
.fi
.LP
\f[B]Notes:\f[R]
.IP \[bu] 3
The namelist itself is inaccessible from the procedure; it is not needed
since the procedure only needs to write the list values in a suitably
formatted way.
Termination of the list is indicated by a final logical value of
\f[CR]F\f[R] in the list entry of the namelist file; the termination
information must be appropriately processed in the corresponding
namelist case of the read procedure.
.IP \[bu] 3
The example implementation does not support \f[CR]DT\f[R] editing;
invoking the parent I/O statement from the above table would therefore
cause error termination unless an \f[CR]iostat=\f[R] argument is added
to it.
.NH 1
Object\-oriented programming techniques
.pdfhref O 1 "\*[SN]  Object-oriented programming techniques"
.pdfhref M "object-oriented-programming-techniques"
.XS
.pdfhref L -D "object-oriented-programming-techniques" \
 -- "	\*[SN]\~\~Object\-oriented programming techniques"
.XE
.NH 1
Introduction: Establishing an explicit relationship between types
.pdfhref O 1 "\*[SN]  Introduction: Establishing an explicit relationship between types"
.pdfhref M "introduction-establishing-an-explicit-relationship-between-types"
.XS
.pdfhref L -D "introduction-establishing-an-explicit-relationship-between-types" \
 -- "	\*[SN]\~\~Introduction: Establishing an explicit relationship between types"
.XE
.LP
The discussion on object\-based program design in the previous chapter
was based on creating derived types that are comprised of objects of
other types (intrinsic or derived); this is also known as \f[B]type\f[R]
\f[B]composition\f[R] (not a Fortran term).
For object\-oriented programming, the approach is that a closer
relationship between two (or maybe more) types can be established
through language\-defined mechanisms, on both the levels of type
definition and object declaration and use.
Fortran supports a \f[B]single inheritance\f[R] model, which will be
outlined in the following sections; runnable example codes are supplied
in the \f[CR]object_oriented\f[R] subfolder of the \c
.pdfhref W -D "https://github.com/reinh-bader/object_fortran" -A "\c" \
 -- "Github repository"
\&
.NH 1
Extension types
.pdfhref O 1 "\*[SN]  Extension types"
.pdfhref M "extension-types"
.XS
.pdfhref L -D "extension-types" \
 -- "	\*[SN]\~\~Extension types"
.XE
.LP
As a starting point, consider the definition of a type, an object of
which can quite generally represent a physical body:
.IP
.nf
\f[C]
\*[DataTypeTok "TYPE"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " body"]
\*[NormalTok "   "]\*[DataTypeTok "REAL"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " mass"]
\*[NormalTok "   "]\*[DataTypeTok "REAL"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " pos("]\*[DecValTok "3"]\*[NormalTok "), vel("]\*[DecValTok "3"]\*[NormalTok ")"]
\*[DataTypeTok "END TYPE"]
\*[NormalTok ":"]
\*[DataTypeTok "TYPE(body)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " my_basketball "]\*[KeywordTok "="]\*[NormalTok " body("]\*[FloatTok "1.5"]\*[NormalTok ", "]\*[KeywordTok "["]\*[FloatTok "0.0"]\*[NormalTok ", "]\*[FloatTok "0.0"]\*[NormalTok ", "]\*[FloatTok "2.0"]\*[KeywordTok "]"]\*[NormalTok ", "]\*[KeywordTok "["]\*[FloatTok "10.0"]\*[NormalTok ", "]\*[FloatTok "0.0"]\*[NormalTok ", "]\*[FloatTok "0.0"]\*[KeywordTok "]"]\*[NormalTok ")"]
\f[]
.fi
.LP
This might come along with procedures that impose a momentum change or a
change of mass on a \f[CR]body\f[R] object:
.IP
.nf
\f[C]
\*[KeywordTok "PURE"]\*[NormalTok " "]\*[KeywordTok "SUBROUTINE"]\*[NormalTok " kick(a_body, dp)"]
\*[NormalTok "   "]\*[DataTypeTok "TYPE(body)"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(inout)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " a_body"]
\*[NormalTok "   "]\*[DataTypeTok "REAL"]\*[NormalTok ", "]\*[DataTypeTok "intent(in)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " dp("]\*[DecValTok "3"]\*[NormalTok ")"]

\*[NormalTok "   a_body"]\*[OperatorTok "%"]\*[NormalTok "vel(:) "]\*[KeywordTok "="]\*[NormalTok " a_body"]\*[OperatorTok "%"]\*[NormalTok "vel(:) "]\*[KeywordTok "+"]\*[NormalTok " dp(:) "]\*[KeywordTok "/"]\*[NormalTok " a_body"]\*[OperatorTok "%"]\*[NormalTok "mass"]
\*[KeywordTok "END SUBROUTINE"]
\*[KeywordTok "PURE"]\*[NormalTok " "]\*[KeywordTok "SUBROUTINE"]\*[NormalTok " accrete(a_body, dm)"]
\*[NormalTok "   "]\*[DataTypeTok "TYPE(body)"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(inout)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " a_body"]
\*[NormalTok "   "]\*[DataTypeTok "REAL"]\*[NormalTok ", "]\*[DataTypeTok "intent(in)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " dm"]

\*[NormalTok "   a_body"]\*[OperatorTok "%"]\*[NormalTok "mass "]\*[KeywordTok "="]\*[NormalTok " a_body"]\*[OperatorTok "%"]\*[NormalTok "mass "]\*[KeywordTok "+"]\*[NormalTok " dm"]
\*[KeywordTok "END SUBROUTINE"]\*[NormalTok " accrete"]
\f[]
.fi
.LP
After writing lots of code that makes use of the above, imagine that you
now want to deal with objects that have the additional property of
electric charge.
One could, of course, simply add another component to the original
\f[CR]body\f[R] type, but in most cases this would invalidate existing
code which would need to be corrected, recompiled and retested.
Furthermore, all \f[CR]body\f[R] objects would require the extra memory,
which for the existing codebase would simply be wasted.
It is more convenient and less intrusive to create a new type that is an
\f[B]extension\f[R] of the existing one (the \f[B]parent\f[R] type):
.IP
.nf
\f[C]
\*[DataTypeTok "TYPE"]\*[NormalTok ", "]\*[DataTypeTok "EXTENDS(body)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " charged_body"]
\*[NormalTok "   "]\*[DataTypeTok "REAL"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " charge"]
\*[DataTypeTok "END TYPE"]
\f[]
.fi
.LP
An object of this type
.IP
.nf
\f[C]
\*[DataTypeTok "TYPE(charged_body)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " a_proton"]
\f[]
.fi
.LP
would then have the following type components:
.IP \[bu] 3
\f[CR]a_proton%mass\f[R]
.IP \[bu] 3
\f[CR]a_proton%pos\f[R]
.IP \[bu] 3
\f[CR]a_proton%vel\f[R]
.LP
that are \f[B]inherited\f[R] from the parent type, and the additional
type component
.IP \[bu] 3
\f[CR]a_proton%charge\f[R]
.LP
that was added in the definition of \f[CR]charged_body\f[R].
Furthermore, it is also possible to reference that part of the object
corresponding to the parent type, which is a subobject of just that
type:
.IP \[bu] 3
\f[CR]a_proton%body\f[R]
.LP
Correspondingly, there are various manners in which the default
structure constructor can be used to create a defined value:
.IP
.nf
\f[C]
\*[DataTypeTok "TYPE(body)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " a_mutilated_proton"]
\*[CommentTok "! Construct a_proton"]
\*[NormalTok "a_proton "]\*[KeywordTok "="]\*[NormalTok " charged_body(mass"]\*[KeywordTok "="]\*[FloatTok "1.672"]\*[NormalTok "E"]\*[KeywordTok "\-"]\*[DecValTok "27"]\*[NormalTok ", pos"]\*[KeywordTok "=["]\*[FloatTok "0.0"]\*[NormalTok ", "]\*[FloatTok "0.0"]\*[NormalTok ", "]\*[FloatTok "0.0"]\*[KeywordTok "]"]\*[NormalTok ", "]\*[KeywordTok "&"]
\*[NormalTok "                        vel"]\*[KeywordTok "=["]\*[FloatTok "0.0"]\*[NormalTok " ,"]\*[FloatTok "0.0"]\*[NormalTok ", "]\*[FloatTok "0.0"]\*[KeywordTok "]"]\*[NormalTok "), charge"]\*[KeywordTok "="]\*[FloatTok "1.602"]\*[NormalTok "E"]\*[KeywordTok "\-"]\*[DecValTok "19"]\*[NormalTok ")"]

\*[CommentTok "! Alternative construction with the same result"]
\*[NormalTok "a_mutilated_proton "]\*[KeywordTok "="]\*[NormalTok " body(mass"]\*[KeywordTok "="]\*[FloatTok "1.672"]\*[NormalTok "E"]\*[KeywordTok "\-"]\*[DecValTok "27"]\*[NormalTok ", pos"]\*[KeywordTok "=["]\*[FloatTok "0.0"]\*[NormalTok ", "]\*[FloatTok "0.0"]\*[NormalTok ", "]\*[FloatTok "0.0"]\*[KeywordTok "]"]\*[NormalTok ", "]\*[KeywordTok "&"]
\*[NormalTok "                          vel"]\*[KeywordTok "=["]\*[FloatTok "0.0"]\*[NormalTok ", "]\*[FloatTok "0.0"]\*[NormalTok ", "]\*[FloatTok "0.0"]\*[KeywordTok "]"]\*[NormalTok ")"]

\*[NormalTok "a_proton "]\*[KeywordTok "="]\*[NormalTok " charged_body(body"]\*[KeywordTok "="]\*[NormalTok "a_mutilated_proton, charge"]\*[KeywordTok "="]\*[FloatTok "1.602"]\*[NormalTok "E"]\*[KeywordTok "\-"]\*[DecValTok "19"]\*[NormalTok ")"]
\f[]
.fi
.LP
Any derived type that does not have the \f[CR]SEQUENCE\f[R] or
\f[CR]BIND(C)\f[R] attributes can be extended in the above manner;
specifically, an extension type can itself be extended.
For any given \[lq]base\[rq] type this gives rise to a potential
hierarchy of types that can be represented by a directed acyclical
graph:
.PDFPIC ./images/Inheritance_diagram.pdf 3i
.QP
\ 

.LP
An object of type \f[CR]body\f[R] is \f[B]type compatible\f[R] with both
\f[CR]a_proton\f[R] and \f[CR]a_mutilated_proton\f[R], so any of these
two can, for example, appear in a call to the procedure \f[CR]kick\f[R].
.NH 1
Polymorphism
.pdfhref O 1 "\*[SN]  Polymorphism"
.pdfhref M "polymorphism"
.XS
.pdfhref L -D "polymorphism" \
 -- "	\*[SN]\~\~Polymorphism"
.XE
.NH 2
Declaring entities with \f[CB]CLASS\f[B]
.pdfhref O 2 "\*[SN]  Declaring entities with CLASS"
.pdfhref M "declaring-entities-with-class"
.XS
.pdfhref L -D "declaring-entities-with-class" \
 -- "		\*[SN]\~\~Declaring entities with \f[CB]CLASS\f[B]"
.XE
.LP
By declaring an object with the \f[CR]CLASS\f[R] instead of the
\f[CR]TYPE\f[R] specifier, is is possible to defer the actual type that
an object has to be determined when the program executes, or even have
the actual type change during program execution.
Such an object is designated as being \f[B]polymorphic\f[R].
To be polymorphic, an object must fulfill one of the following
prerequisites:
.IP \[bu] 3
it has the \f[CR]POINTER\f[R] attribute,
.IP \[bu] 3
it has the \f[CR]ALLOCATABLE\f[R] attribute, or
.IP \[bu] 3
it is a dummy argument (with or without a \f[CR]POINTER\f[R] or
\f[CR]ALLOCATABLE\f[R] attribute).
.LP
For example, the typed alllocation statement executed on a polymorphic
allocatable object
.IP
.nf
\f[C]
\*[DataTypeTok "CLASS(body)"]\*[NormalTok ", "]\*[DataTypeTok "ALLOCATABLE"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " a_polymorphic_body"]
\*[NormalTok ":"]
\*[KeywordTok "ALLOCATE"]\*[NormalTok "( charged_body "]\*[DataTypeTok "::"]\*[NormalTok " a_polymorphic_body )"]
\f[]
.fi
.LP
causes the object \f[CR]a_polymorphic_body\f[R] that has the
\f[B]declared\f[R] type \f[CR]body\f[R] to be allocated with the
\f[B]dynamic\f[R] type \f[CR]charged_body\f[R]; in Fortran nomenclature,
the latter term denotes what was referred to above as \[lq]actual\[rq]
type.
.PP
\f[I]Hint:\f[R] For an unallocated allocatable or a disassociated
pointer the dynamic type is considered to be the same as the declared
type, although this is only useful in very few contexts that do not
require the object to be allocated or associated.
.NH 2
Run\-time type and class identification
.pdfhref O 2 "\*[SN]  Run-time type and class identification"
.pdfhref M "run-time-type-and-class-identification"
.XS
.pdfhref L -D "run-time-type-and-class-identification" \
 -- "		\*[SN]\~\~Run\-time type and class identification"
.XE
.LP
Within the scope of the object\[cq]s declaration, only the components of
its declared type are accessible.
Also, I/O operations on a polymorphic object are not permitted, unless
UDDTIO routines have been defined.
One way to obtain access to the complete object is to use a construct
that permits \f[B]run\-time type identification\f[R] (not a Fortran
term), \f[CR]SELECT TYPE\f[R].
For example, the I/O statements in
.IP
.nf
\f[C]
\*[KeywordTok "SELECT TYPE"]\*[NormalTok " (a_polymorphic_body)"]
\*[KeywordTok "TYPE IS"]\*[NormalTok " (body)"]
\*[NormalTok "   "]\*[FunctionTok "WRITE(*"]\*[NormalTok ","]\*[FunctionTok "*)"]\*[NormalTok " "]\*[StringTok "\[aq]object of type body has value        \[aq]"]\*[NormalTok ", a_polymorphic_body"]
\*[KeywordTok "TYPE IS"]\*[NormalTok " (charged_body)"]
\*[NormalTok "   "]\*[FunctionTok "WRITE(*"]\*[NormalTok ","]\*[FunctionTok "*)"]\*[NormalTok " "]\*[StringTok "\[aq]object of type charged_body has value\[aq]"]\*[NormalTok ", a_polymorphic_body"]
\*[KeywordTok "CLASS default"]
\*[NormalTok "   ERROR "]\*[KeywordTok "STOP"]\*[NormalTok " "]\*[StringTok "\[aq]Type extension unsupported in this construct\[aq]"]
\*[KeywordTok "END SELECT"]
\f[]
.fi
.LP
are permitted, since inside the block for each \f[B]type guard\f[R] the
object is non\-polymorphic and of the specified type.
At most one type guard can match the object\[cq]s type, and the
corresponding statements are executed; otherwise the
\f[CR]CLASS default\f[R] section is executed (and the object remains
polymorphic there).
A disadvantage of using \f[CR]SELECT TYPE\f[R] is that it needs to be
appropriately updated whenever an additional type extension is defined;
apart from the maintenance effort this also requires access to all
source code that contain a relevant instance of the construct.
For this reason, type\-bound procedures (to be discussed) should be
preferably used to gain access to additional type components.
.PP
For updates of the \f[CR]charge\f[R] component of a
\f[CR]charged_body\f[R] object, one now could consider the following:
.IP
.nf
\f[C]
\*[KeywordTok "SUBROUTINE"]\*[NormalTok " recharge(a_charged_body, dq)"]
\*[NormalTok "   "]\*[DataTypeTok "TYPE(charged_body)"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(inout)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " a_charged_body"]
\*[NormalTok "   "]\*[DataTypeTok "REAL"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(in)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " dq"]

\*[NormalTok "   a_charged_body"]\*[OperatorTok "%"]\*[NormalTok "charge "]\*[KeywordTok "="]\*[NormalTok " a_charged_body"]\*[OperatorTok "%"]\*[NormalTok "charge "]\*[KeywordTok "+"]\*[NormalTok " dq"]
\*[KeywordTok "END SUBROUTINE"]
\f[]
.fi
.LP
However, invoking this subroutine in the usual Fortran 95 style will not
work for the variable \f[CR]a_polymorphic_body\f[R], since it violates
the rule that the dummy argument\[cq]s declared type must be type
compatible with the actual argument\[cq]s declared type.
One can work around this by using a \f[CR]SELECT TYPE\f[R] construct
with \f[B]run\-time class identification\f[R] (not a Fortran term),
based on writing \f[B]class guards\f[R] instead of type guards:
.IP
.nf
\f[C]
\*[KeywordTok "SELECT TYPE"]\*[NormalTok " (a_polymorphic_body)"]
\*[KeywordTok "CLASS IS"]\*[NormalTok " (charged_body)  "]\*[CommentTok "! new declared type for a_polymorphic_body"]
\*[NormalTok "   "]\*[KeywordTok "CALL"]\*[NormalTok " recharge(a_polymorphic_body, dq"]\*[KeywordTok "="]\*[FloatTok "1.0e\-5"]\*[NormalTok ")"]
\*[KeywordTok "CLASS default"]
\*[NormalTok "   "]\*[FunctionTok "WRITE(*"]\*[NormalTok ","]\*[FunctionTok "*)"]\*[NormalTok " "]\*[StringTok "\[aq]INFO: object a_polymorphic_body was not modified.\[aq]"]
\*[KeywordTok "END SELECT"]
\f[]
.fi
.LP
The \f[CR]recharge\f[R] procedure will then be invoked if the dynamic
type of \f[CR]a_polymorphic_body\f[R] is \f[CR]charged_body\f[R] or an
extension of it.
The object remains polymorphic inside the class guard, only its declared
type changes to that specified in the guard.
Unless the \[lq]lifted\[rq] declared type of interest is already
otherwise known from the context, or handling the
\f[CR]CLASS default\f[R] fall\-through is straightforward, this is not
in general a desirable way of dealing with class mismatches.
.PP
\f[I]Hint:\f[R] It is permitted to mix type and class guards in a
\f[CR]SELECT TYPE\f[R] construct; in that case, a type guard has
precedence over a class guard specifying the same type with respect to
selection of the guarded statements to be executed.
.NH 2
Unlimited polymorphic objects
.pdfhref O 2 "\*[SN]  Unlimited polymorphic objects"
.pdfhref M "unlimited-polymorphic-objects"
.XS
.pdfhref L -D "unlimited-polymorphic-objects" \
 -- "		\*[SN]\~\~Unlimited polymorphic objects"
.XE
.LP
A special case of polymorphism is that an object can be \f[B]unlimited
polymorphic\f[R].
Such an object, declared with \f[CR]CLASS(*)\f[R], can be of any dynamic
type (intrinsic type, extensible derived type, \f[CR]SEQUENCE\f[R] or
\f[CR]BIND(C)\f[R] derived type), as illustrated by the following
statements:
.IP
.nf
\f[C]
\*[DataTypeTok "CLASS(*)"]\*[NormalTok ", "]\*[DataTypeTok "ALLOCATABLE"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " a_unlimited  "]\*[CommentTok "! has no declared type, so any type is an extension"]

\*[KeywordTok "ALLOCATE"]\*[NormalTok "( a_unlimited, source"]\*[KeywordTok "="]\*[FloatTok "2.5"]\*[NormalTok "E4)  "]\*[CommentTok "! dynamic type becomes real"]

\*[KeywordTok "SELECT TYPE"]\*[NormalTok " ( a_unlimited )"]
\*[KeywordTok "TYPE IS"]\*[NormalTok " ("]\*[DataTypeTok "REAL"]\*[NormalTok ")"]
\*[NormalTok "   "]\*[FunctionTok "WRITE(*"]\*[NormalTok ","]\*[FunctionTok "*)"]\*[NormalTok " "]\*[StringTok "\[aq]a_unlimited is of intrinsic real type with value \[aq]"]\*[NormalTok ", a_unlimited"]
\*[KeywordTok "END SELECT"]

\*[KeywordTok "DEALLOCATE"]\*[NormalTok "( a_unlimited )"]
\*[KeywordTok "ALLOCATE"]\*[NormalTok "( a_unlimited, source"]\*[KeywordTok "="]\*[NormalTok "a_proton) )  "]\*[CommentTok "! dynamic type becomes charged_body"]

\*[KeywordTok "SELECT TYPE"]\*[NormalTok " ( a_unlimited )"]
\*[KeywordTok "TYPE IS"]\*[NormalTok " (charged_body)"]
\*[NormalTok "   "]\*[FunctionTok "WRITE(*"]\*[NormalTok ","]\*[FunctionTok "*)"]\*[NormalTok " "]\*[StringTok "\[aq]a_unlimited is a charged_body with value \[aq]"]\*[NormalTok ", a_unlimited"]
\*[KeywordTok "END SELECT"]
\f[]
.fi
.LP
Accessing the object\[cq]s data \f[I]always\f[R] needs a
\f[CR]SELECT TYPE\f[R] construct; type guards in the construct can in
this case might not only refer to extensible types, but also to
intrinsic types.
However, for \f[CR]SEQUENCE\f[R] or \f[CR]BIND(C)\f[R] derived types, no
type resolution is possible \- these always fall through to a
\f[CR]CLASS default\f[R] guard, if present; use of unlimited polymorphic
objects to store values of such types is therefore considered unsafe.
.PP
In this context, allocation with \f[CR]source=\f[R] allocates the target
object to the source object\[cq]s dynamic type before copying its value
to the target object.
If the source object\[cq]s data is not needed, \f[CR]mold=\f[R] can be
used instead.
Sourced allocation becomes a powerful tool, since the dynamic type of
the source object need not be known in the scoping unit within which the
allocation is executed.
.PP
Type components with the \f[CR]POINTER\f[R] or \f[CR]ALLOCATABLE\f[R]
attribute can be unlimited polymorphic, enabling the construction of
generic and potentially inhomogeneous container\-like types.
As an illustration of this, a supporting type for the purpose of holding
data targeted for manipulation of other objects is presented; its
definition (placed in the module \f[CR]mod_utility_types\f[R]) reads
.IP
.nf
\f[C]
\*[DataTypeTok "TYPE"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " any_object"]
\*[NormalTok "   "]\*[DataTypeTok "CHARACTER(len=:)"]\*[NormalTok ", "]\*[DataTypeTok "ALLOCATABLE"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " description"]
\*[NormalTok "   "]\*[DataTypeTok "CLASS(*)"]\*[NormalTok ", "]\*[DataTypeTok "ALLOCATABLE"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " "]\*[DataTypeTok "value"]\*[NormalTok "(:)"]
\*[NormalTok "   "]\*[DataTypeTok "INTEGER"]\*[NormalTok ", "]\*[DataTypeTok "ALLOCATABLE"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " "]\*[FunctionTok "shape"]\*[NormalTok "(:)"]
\*[DataTypeTok "END TYPE"]
\f[]
.fi
.LP
where \f[CR]description\f[R] will refer to the property that needs
updating, and \f[CR]value\f[R] will contain the data to be used for the
transaction.
Because the \f[CR]value\f[R] component should be able to represent any
type, it is declared as being unlimited polymorphic.
Because the \f[CR]value\f[R] component might hold data needed to produce
an array of arbitrary shape, the additional \f[CR]shape\f[R] component
is supplied, but its use is really only necessary if objects of rank at
least 2 must be dealt with.
The structure constructor for that type has been overloaded to work
around compiler bugs and make handling of scalar data easier.
The following example illustrates how to establish a simple interface
for setting components of a structure:
.IP
.nf
\f[C]
\*[KeywordTok "MODULE"]\*[NormalTok " mod_wtype"]
\*[NormalTok "   "]\*[KeywordTok "USE"]\*[NormalTok " mod_utility_types, "]\*[KeywordTok "ONLY"]\*[NormalTok " : initialize "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " any_object"]

\*[NormalTok "   "]\*[DataTypeTok "TYPE"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " wtype"]
\*[NormalTok "      "]\*[DataTypeTok "PRIVATE"]
\*[NormalTok "      "]\*[DataTypeTok "INTEGER"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " nonzeros "]\*[KeywordTok "="]\*[NormalTok " "]\*[KeywordTok "\-"]\*[DecValTok "1"]
\*[NormalTok "      "]\*[DataTypeTok "REAL"]\*[NormalTok ", "]\*[DataTypeTok "ALLOCATABLE"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " w(:,:)"]
\*[NormalTok "   "]\*[DataTypeTok "END TYPE"]\*[NormalTok " wtype"]
\*[KeywordTok "CONTAINS"]
\*[NormalTok "   "]\*[KeywordTok "SUBROUTINE"]\*[NormalTok " setup_wtype(a_wtype, a_component)"]
\*[NormalTok "      "]\*[CommentTok "! in\-place setting to avoid memory bursts for large objects"]
\*[NormalTok "      "]\*[DataTypeTok "TYPE(wtype)"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(inout)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " a_wtype"]
\*[NormalTok "      "]\*[DataTypeTok "TYPE(initialize)"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(in)"]\*[NormalTok ", "]\*[DataTypeTok "TARGET"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " a_component"]
\*[NormalTok "      "]\*[DataTypeTok "INTEGER"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " wsize"]
\*[NormalTok "      "]\*[DataTypeTok "REAL"]\*[NormalTok ", "]\*[DataTypeTok "POINTER"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " pw(:,:)"]

\*[NormalTok "      "]\*[KeywordTok "SELECT CASE"]\*[NormalTok " (a_component"]\*[OperatorTok "%"]\*[NormalTok "description)"]
\*[NormalTok "      "]\*[KeywordTok "CASE"]\*[NormalTok " ("]\*[StringTok "\[dq]nonzeros\[dq]"]\*[NormalTok ")"]
\*[NormalTok "         "]\*[KeywordTok "IF"]\*[NormalTok " ( "]\*[FunctionTok "allocated"]\*[NormalTok "(a_component"]\*[OperatorTok "%"]\*[DataTypeTok "value"]\*[NormalTok ") ) "]\*[KeywordTok "THEN"]
\*[NormalTok "            "]\*[KeywordTok "SELECT TYPE"]\*[NormalTok " ( nonzeros "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " a_component"]\*[OperatorTok "%"]\*[DataTypeTok "value"]\*[NormalTok "("]\*[DecValTok "1"]\*[NormalTok ") )"]
\*[NormalTok "            "]\*[KeywordTok "TYPE IS"]\*[NormalTok " ("]\*[DataTypeTok "INTEGER"]\*[NormalTok ")"]
\*[NormalTok "               a_wtype"]\*[OperatorTok "%"]\*[NormalTok "nonzeros "]\*[KeywordTok "="]\*[NormalTok " nonzeros"]
\*[NormalTok "            "]\*[KeywordTok "END SELECT"]
\*[NormalTok "         "]\*[KeywordTok "END IF"]
\*[NormalTok "      "]\*[KeywordTok "CASE"]\*[NormalTok " ("]\*[StringTok "\[dq]w\[dq]"]\*[NormalTok ")"]
\*[NormalTok "         "]\*[KeywordTok "IF"]\*[NormalTok " ( "]\*[FunctionTok "allocated"]\*[NormalTok "(a_component"]\*[OperatorTok "%"]\*[DataTypeTok "value"]\*[NormalTok ") "]\*[OperatorTok ".AND."]\*[NormalTok " "]\*[FunctionTok "allocated"]\*[NormalTok "(a_component"]\*[OperatorTok "%"]\*[FunctionTok "shape"]\*[NormalTok ") ) "]\*[KeywordTok "THEN"]
\*[NormalTok "            wsize "]\*[KeywordTok "="]\*[NormalTok " "]\*[FunctionTok "size"]\*[NormalTok "(a_component"]\*[OperatorTok "%"]\*[DataTypeTok "value"]\*[NormalTok ")"]
\*[NormalTok "            "]\*[KeywordTok "IF"]\*[NormalTok " ( wsize "]\*[OperatorTok ">="]\*[NormalTok " "]\*[FunctionTok "product"]\*[NormalTok "(a_component"]\*[OperatorTok "%"]\*[FunctionTok "shape"]\*[NormalTok ") ) "]\*[KeywordTok "THEN"]
\*[NormalTok "               "]\*[KeywordTok "SELECT TYPE"]\*[NormalTok " ( w "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " a_component"]\*[OperatorTok "%"]\*[DataTypeTok "value"]\*[NormalTok " )"]
\*[NormalTok "               "]\*[KeywordTok "TYPE IS"]\*[NormalTok " ("]\*[DataTypeTok "REAL"]\*[NormalTok ")"]
\*[NormalTok "                  pw("]\*[DecValTok "1"]\*[NormalTok ":a_component"]\*[OperatorTok "%"]\*[FunctionTok "shape"]\*[NormalTok "("]\*[DecValTok "1"]\*[NormalTok "), "]\*[DecValTok "1"]\*[NormalTok ":a_component"]\*[OperatorTok "%"]\*[FunctionTok "shape"]\*[NormalTok "("]\*[DecValTok "2"]\*[NormalTok ")) "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " w"]
\*[NormalTok "                  a_wtype"]\*[OperatorTok "%"]\*[NormalTok "w "]\*[KeywordTok "="]\*[NormalTok " pw"]
\*[NormalTok "               "]\*[KeywordTok "END SELECT"]
\*[NormalTok "            "]\*[KeywordTok "END IF"]
\*[NormalTok "         "]\*[KeywordTok "END IF"]
\*[NormalTok "      "]\*[KeywordTok "END SELECT"]
\*[NormalTok "   "]\*[KeywordTok "END SUBROUTINE"]\*[NormalTok " setup_wtype"]
\*[NormalTok "   :"]
\*[KeywordTok "END MODULE"]
\f[]
.fi
.LP
\f[B]Notes:\f[R]
.IP \[bu] 3
Having this simple interface at the cost of significant additional setup
code might at first sight appear frivolous; however, once type extension
is used on a larger scale, setting or modifying further components in
the conventional way becomes rather irksome without a concept like that
above, especially if \c
.pdfhref L -D "sec:tbp" -A "\c" \
 -- "type\-bound procedures"
\& with a simple \f[I]and\f[R] uniform interface must be implemented;
.IP \[bu] 3
The object \f[CR]a_wtype\f[R] remains unchanged in case an unsuitable
value is provided for \f[CR]a_component\f[R].
One could add explicit error handling, but for these examples this is
considered an unnecessary complication;
.IP \[bu] 3
The permitted values for the \f[CR]initialize\f[R] object should be
documented for each procedure that takes such an object;
.IP \[bu] 3
Because access to \f[CR]a_component\f[R] within \f[CR]SELECT TYPE\f[R]
is via a type component, one is obliged to introduce an associate name
for the latter.
The language rules only permit omitting the associate name for named
variables, and subobjects are not named variables;
.IP \[bu] 3
A \f[B]rank\-changing pointer assignment\f[R] is used to transform the
rank\-1 \f[CR]a_component%value\f[R] array to an object that can be
assigned to a rank\-2 \f[CR]a_wtype%w\f[R] array; this works because the
right\-hand side is a rank\-1 object; for rank\-2 and higher the
rank\-changing pointer assignment will only work if the target assigned
to is a \f[B]simply contiguous array designator\f[R] (a topic not
covered here).
Note that in this context, the \f[CR]reshape\f[R] intrinsic cannot be
used because it requires the size of its \f[CR]shape\f[R] argument to be
a constant.
.LP
The program invoking the \f[CR]setup_wtype\f[R] procedure might do so as
follows, to set up a \f[CR]wtype\f[R] object:
.IP
.nf
\f[C]
\*[KeywordTok "USE"]\*[NormalTok " mod_wtype"]
\*[DataTypeTok "TYPE(initialize)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " c_nz, c_w"]
\*[DataTypeTok "TYPE(wtype)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " my_wtype"]
\*[DataTypeTok "INTEGER"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " i, j"]
\*[DataTypeTok "INTEGER"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " ndim"]

\*[NormalTok "ndim "]\*[KeywordTok "="]\*[NormalTok " ..."]

\*[KeywordTok "ASSOCIATE"]\*[NormalTok " ( my_data "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " "]\*[KeywordTok "["]\*[NormalTok " (("]\*[DataTypeTok "real (max(0, min(i\-j+2, j\-i+2)))"]\*[NormalTok ", j"]\*[KeywordTok "="]\*[DecValTok "1"]\*[NormalTok ", ndim), i"]\*[KeywordTok "="]\*[DecValTok "1"]\*[NormalTok ", ndim) "]\*[KeywordTok "]"]\*[NormalTok " )"]
\*[NormalTok "   c_nz "]\*[KeywordTok "="]\*[NormalTok " initialize("]\*[StringTok "\[dq]nonzeros\[dq]"]\*[NormalTok ", "]\*[FunctionTok "count"]\*[NormalTok "(my_data "]\*[OperatorTok "/="]\*[NormalTok " "]\*[DecValTok "0"]\*[NormalTok "))"]
\*[NormalTok "   c_w "]\*[KeywordTok "="]\*[NormalTok " initialize("]\*[StringTok "\[dq]w\[dq]"]\*[NormalTok ", my_data, "]\*[KeywordTok "["]\*[NormalTok " ndim, ndim "]\*[KeywordTok "]"]\*[NormalTok " )"]
\*[KeywordTok "END ASSOCIATE"]

\*[KeywordTok "CALL"]\*[NormalTok " setup_wtype(my_wtype, c_nz)"]
\*[KeywordTok "CALL"]\*[NormalTok " setup_wtype(my_wtype, c_w)"]
\f[]
.fi
.NH 1
Type\-bound procedures (TBP)
.pdfhref O 1 "\*[SN]  Type-bound procedures \(TBP\)"
.pdfhref M "sec:tbp"
.XS
.pdfhref L -D "sec:tbp" \
 -- "	\*[SN]\~\~Type\-bound procedures (TBP)"
.XE
.LP
To resolve the class mismatch issues arising from the use of polymorphic
objects, one needs a language mechanism for making a run\-time decision
on a procedure invocation that depends on the dynamic type of a
polymorphic object.
This can be achieved by binding a procedure to a type in the type
definition via a \f[CR]PROCEDURE\f[R] statement in the type\[cq]s
\f[CR]CONTAINS\f[R] part.
.PP
For the type \f[CR]body\f[R], the augmented type definition reads
.IP
.nf
\f[C]
\*[DataTypeTok "TYPE"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " body"]
\*[NormalTok "   "]\*[DataTypeTok "REAL"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " mass"]
\*[NormalTok "   "]\*[DataTypeTok "REAL"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " pos("]\*[DecValTok "3"]\*[NormalTok "), vel("]\*[DecValTok "3"]\*[NormalTok ")"]
\*[KeywordTok "CONTAINS"]
\*[NormalTok "   "]\*[DataTypeTok "PROCEDURE"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " update "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " update_body"]
\*[DataTypeTok "END TYPE"]
\f[]
.fi
.LP
This does not impact how the structure constructor is used; for this,
only the specifications before the \f[CR]CONTAINS\f[R] statement are
relevant.
To establish a simple and uniform interface for object updates, the
procedure \f[CR]update_body\f[R] makes use of the \f[CR]any_object\f[R]
type discussed earlier, which in view of the context is locally renamed
to \f[CR]change\f[R]:
.IP
.nf
\f[C]
\*[KeywordTok "SUBROUTINE"]\*[NormalTok " update_body(a_body, a_change)"]
\*[NormalTok "   "]\*[DataTypeTok "CLASS(body)"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(inout)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " a_body"]
\*[NormalTok "   "]\*[DataTypeTok "TYPE(change)"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(in)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " a_change"]
\*[NormalTok "   "]\*[KeywordTok "IF"]\*[NormalTok " ( "]\*[FunctionTok "allocated"]\*[NormalTok "(a_change"]\*[OperatorTok "%"]\*[NormalTok "description) "]\*[OperatorTok ".AND."]\*[NormalTok " "]\*[FunctionTok "allocated"]\*[NormalTok "(a_change"]\*[OperatorTok "%"]\*[DataTypeTok "value"]\*[NormalTok ") ) "]\*[KeywordTok "THEN"]
\*[NormalTok "     "]\*[KeywordTok "SELECT CASE"]\*[NormalTok " ( "]\*[FunctionTok "trim"]\*[NormalTok "(a_change"]\*[OperatorTok "%"]\*[NormalTok "description) )"]
\*[NormalTok "     "]\*[KeywordTok "CASE"]\*[NormalTok " ("]\*[StringTok "\[aq]mass\[aq]"]\*[NormalTok ")"]
\*[NormalTok "        "]\*[KeywordTok "SELECT TYPE"]\*[NormalTok " ( delta "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " a_change"]\*[OperatorTok "%"]\*[DataTypeTok "value"]\*[NormalTok "("]\*[DecValTok "1"]\*[NormalTok ") )"]
\*[NormalTok "        "]\*[KeywordTok "TYPE IS"]\*[NormalTok " ("]\*[DataTypeTok "real"]\*[NormalTok ")"]
\*[NormalTok "           "]\*[KeywordTok "CALL"]\*[NormalTok " accrete(a_body, delta)"]
\*[NormalTok "        "]\*[KeywordTok "END SELECT"]
\*[NormalTok "     "]\*[KeywordTok "CASE"]\*[NormalTok " ("]\*[StringTok "\[aq]momentum\[aq]"]\*[NormalTok ")"]
\*[NormalTok "        "]\*[KeywordTok "SELECT TYPE"]\*[NormalTok " ( delta "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " a_change"]\*[OperatorTok "%"]\*[DataTypeTok "value"]\*[NormalTok " )"]
\*[NormalTok "        "]\*[KeywordTok "TYPE IS"]\*[NormalTok " ("]\*[DataTypeTok "real"]\*[NormalTok ")"]
\*[NormalTok "           "]\*[KeywordTok "IF"]\*[NormalTok " ( "]\*[FunctionTok "size"]\*[NormalTok "(delta) "]\*[OperatorTok ">="]\*[NormalTok " "]\*[DecValTok "3"]\*[NormalTok " ) "]\*[KeywordTok "CALL"]\*[NormalTok " kick(a_body, delta("]\*[DecValTok "1"]\*[NormalTok ":"]\*[DecValTok "3"]\*[NormalTok "))"]
\*[NormalTok "        "]\*[KeywordTok "END SELECT"]
\*[NormalTok "     "]\*[KeywordTok "CASE"]\*[NormalTok " ("]\*[StringTok "\[aq]position\[aq]"]\*[NormalTok ")"]
\*[NormalTok "        "]\*[KeywordTok "SELECT TYPE"]\*[NormalTok " ( delta "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " a_change"]\*[OperatorTok "%"]\*[DataTypeTok "value"]\*[NormalTok " )"]
\*[NormalTok "        "]\*[KeywordTok "TYPE IS"]\*[NormalTok " ("]\*[DataTypeTok "real"]\*[NormalTok ")"]
\*[NormalTok "           "]\*[KeywordTok "IF"]\*[NormalTok " ( "]\*[FunctionTok "size"]\*[NormalTok "(delta) "]\*[OperatorTok ">="]\*[NormalTok " "]\*[DecValTok "3"]\*[NormalTok ") a_body"]\*[OperatorTok "%"]\*[NormalTok "pos "]\*[KeywordTok "="]\*[NormalTok " a_body"]\*[OperatorTok "%"]\*[NormalTok "pos "]\*[KeywordTok "+"]\*[NormalTok " delta("]\*[DecValTok "1"]\*[NormalTok ":"]\*[DecValTok "3"]\*[NormalTok ")"]
\*[NormalTok "        "]\*[KeywordTok "END SELECT"]
\*[NormalTok "     "]\*[KeywordTok "END SELECT"]
\*[NormalTok "   "]\*[KeywordTok "END IF"]
\*[KeywordTok "END SUBROUTINE"]
\f[]
.fi
.LP
In its interface, the \f[B]passed object\f[R] \f[CR]a_body\f[R] must be
declared to be a polymorphic scalar, with its declared type being the
one the procedure has been bound to.
The implementation reuses existing code where possible (very simple in
this example, but this is of course not generally the case), to avoid
the need for extensive revalidation.
.PP
Invocation of the procedure could be done in the usual manner, but the
preferred style, especially in the case that the actual argument is
polymorphic, is to do it through the object itself:
.IP
.nf
\f[C]
\*[DataTypeTok "TYPE(change)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok "  dx"]
\*[NormalTok ":"]
\*[NormalTok "dx "]\*[KeywordTok "="]\*[NormalTok " change(description"]\*[KeywordTok "="]\*[StringTok "\[aq]mass\[aq]"]\*[NormalTok ", "]\*[DataTypeTok "value"]\*[KeywordTok "=["]\*[FloatTok "0.0"]\*[NormalTok ", "]\*[FloatTok "2.0"]\*[NormalTok ", "]\*[FloatTok "0.0"]\*[KeywordTok "]"]\*[NormalTok ")"]

\*[KeywordTok "CALL"]\*[NormalTok " my_basketball"]\*[OperatorTok "%"]\*[NormalTok "update(dx) "]\*[CommentTok "! invokes update_body(my_basketball, dx)"]
\f[]
.fi
.LP
For polymorphic objects, the procedure \f[CR]update_body\f[R] will be
invoked if the dynamic type of the object is \f[CR]body\f[R] (this might
not be true if the dynamic type is an extension, as we shall see).
.PP
\f[I]Hint:\f[R] The invocation can also be done with non\-polymorphic
objects; in this case, the binding could (in principle) be determined at
compilation time, potentially saving some call overhead.
Note that the passed object dummy is not permitted to be allocatable or
a pointer, which facilitates this usage.
.PP
So far this is not particularly interesting; the key thing is what
happens once we turn to type extensions.
For example, to enable modification of the \f[CR]charge\f[R] component
(in addition to that of other components) of an object of dynamic type
\f[CR]charged_body\f[R], it is possible to \f[B]override\f[R] the parent
type\[cq]s bound procedure:
.IP
.nf
\f[C]
\*[DataTypeTok "TYPE"]\*[NormalTok ", "]\*[DataTypeTok "EXTENDS(body)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " charged_body"]
\*[NormalTok "   "]\*[DataTypeTok "REAL"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " charge"]
\*[KeywordTok "CONTAINS"]
\*[NormalTok "   "]\*[DataTypeTok "PROCEDURE"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " update "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " update_charged_body"]
\*[DataTypeTok "END TYPE"]
\f[]
.fi
.LP
with the procedure defined as follows:
.IP
.nf
\f[C]
\*[KeywordTok "SUBROUTINE"]\*[NormalTok " update_charged_body(a_body, a_change)"]
\*[NormalTok "   "]\*[DataTypeTok "CLASS(charged_body)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " a_body"]
\*[NormalTok "   "]\*[DataTypeTok "TYPE(change)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " a_change"]

\*[NormalTok "   "]\*[KeywordTok "IF"]\*[NormalTok " ( "]\*[FunctionTok "allocated"]\*[NormalTok "(a_change"]\*[OperatorTok "%"]\*[NormalTok "description) "]\*[OperatorTok ".AND."]\*[NormalTok " "]\*[FunctionTok "allocated"]\*[NormalTok "(a_change"]\*[OperatorTok "%"]\*[DataTypeTok "value"]\*[NormalTok ") ) "]\*[KeywordTok "THEN"]
\*[NormalTok "      "]\*[KeywordTok "SELECT CASE"]\*[NormalTok " ( "]\*[FunctionTok "trim"]\*[NormalTok "(a_change"]\*[OperatorTok "%"]\*[NormalTok "description) )"]
\*[NormalTok "      "]\*[KeywordTok "CASE"]\*[NormalTok " ("]\*[StringTok "\[aq]charge\[aq]"]\*[NormalTok ")"]
\*[NormalTok "         "]\*[KeywordTok "SELECT TYPE"]\*[NormalTok " ( delta "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " a_change"]\*[OperatorTok "%"]\*[DataTypeTok "value"]\*[NormalTok "("]\*[DecValTok "1"]\*[NormalTok ") )"]
\*[NormalTok "         "]\*[KeywordTok "TYPE IS"]\*[NormalTok " ("]\*[DataTypeTok "real"]\*[NormalTok ")"]
\*[NormalTok "            a_body"]\*[OperatorTok "%"]\*[NormalTok "charge "]\*[KeywordTok "="]\*[NormalTok " a_body"]\*[OperatorTok "%"]\*[NormalTok "charge "]\*[KeywordTok "+"]\*[NormalTok " delta"]
\*[NormalTok "         "]\*[KeywordTok "END SELECT"]
\*[NormalTok "      "]\*[KeywordTok "CASE default"]
\*[NormalTok "         "]\*[KeywordTok "CALL"]\*[NormalTok " a_body"]\*[OperatorTok "%"]\*[NormalTok "body"]\*[OperatorTok "%"]\*[NormalTok "update(a_change)"]
\*[NormalTok "         "]\*[CommentTok "! assure that a change to a parent component is dealt with"]
\*[NormalTok "      "]\*[KeywordTok "END SELECT"]
\*[NormalTok "   "]\*[KeywordTok "END IF"]
\*[KeywordTok "END SUBROUTINE"]
\f[]
.fi
.LP
The overriding procedure must use the same interface as the overridden
procedure, except that the passed object is declared to be of the
extended type; even the argument keywords must be the same.
Once the override has been defined, the call through an object of
dynamic type \f[CR]charged_body\f[R] will be dispatched to
\f[CR]update_charged_body\f[R]:
.IP
.nf
\f[C]
\*[DataTypeTok "TYPE(change)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok "  dc, dp"]
\*[DataTypeTok "CLASS(body)"]\*[NormalTok ", "]\*[DataTypeTok "ALLOCATABLE"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " my_polymorphic_body"]

\*[NormalTok "my_polymorphic_body "]\*[KeywordTok "="]\*[NormalTok " charged_body(mass"]\*[KeywordTok "="]\*[FloatTok "1.5"]\*[NormalTok ", pos"]\*[KeywordTok "=["]\*[FloatTok "0."]\*[NormalTok ","]\*[FloatTok "0."]\*[NormalTok ","]\*[FloatTok "0."]\*[KeywordTok "]"]\*[NormalTok ", "]\*[KeywordTok "&"]
\*[NormalTok "                                   vel"]\*[KeywordTok "=["]\*[FloatTok "2."]\*[NormalTok ","]\*[FloatTok "0."]\*[NormalTok ","]\*[FloatTok "0."]\*[KeywordTok "]"]\*[NormalTok ", charge"]\*[KeywordTok "="]\*[FloatTok "2.41"]\*[NormalTok "E"]\*[KeywordTok "\-"]\*[DecValTok "5"]\*[NormalTok ")"]
\*[CommentTok "!  the above statement auto\-allocates the left hand side"]
\*[NormalTok "dc "]\*[KeywordTok "="]\*[NormalTok " change(description"]\*[KeywordTok "="]\*[StringTok "\[aq]charge\[aq]"]\*[NormalTok ", "]\*[DataTypeTok "value"]\*[KeywordTok "="]\*[FloatTok "5.0"]\*[NormalTok "E"]\*[KeywordTok "\-"]\*[DecValTok "6"]\*[NormalTok ")"]
\*[NormalTok "dp "]\*[KeywordTok "="]\*[NormalTok " change(description"]\*[KeywordTok "="]\*[StringTok "\[aq]momentum\[aq]"]\*[NormalTok ", "]\*[DataTypeTok "value"]\*[KeywordTok "=[\-"]\*[FloatTok "1.0"]\*[NormalTok ","]\*[FloatTok "1.0"]\*[NormalTok ","]\*[FloatTok "0.0"]\*[KeywordTok "]"]\*[NormalTok ")"]

\*[CommentTok "! both the following dispatch to update_charged_body"]
\*[KeywordTok "CALL"]\*[NormalTok " my_polymorphic_body"]\*[OperatorTok "%"]\*[NormalTok "update(dc)"]
\*[KeywordTok "CALL"]\*[NormalTok " my_polymorphic_body"]\*[OperatorTok "%"]\*[NormalTok "update(dp)"]
\f[]
.fi
.LP
\f[B]Notes:\f[R]
.IP \[bu] 3
for the above example, direct invocation of the procedure
\f[CR]update_charged_body\f[R] is not possible (as already noted
earlier);
.IP \[bu] 3
the second TBP call illustrates the invocation of the parent object
update from \f[CR]update_charged_body\f[R].
Without this, changes that impact the parent object would not be done.
By implementing this consistency of behaviour, the programmer assures
that the inheritance hierarchy adheres to the \c
.pdfhref W -D "https://en.wikipedia.org/wiki/Liskov_substitution_principle" -A "\c" \
 -- "Liskov substitution principle"
\&;
.IP \[bu] 3
to enforce using the TBP calls in a use association context, the module
procedures that implement them can be made \f[CR]PRIVATE\f[R].
The accessibility of the TBP itself is determined by the attribute for
it (default is \f[CR]PUBLIC\f[R]) in the type definition;
.IP \[bu] 3
the programmer can prevent overriding of a binding by declaring it to be
\f[CR]NON_OVERRIDABLE\f[R]; its implementation then is regarded as valid
for all conceivable extension types.
.NH 1
Abstract types and interfaces
.pdfhref O 1 "\*[SN]  Abstract types and interfaces"
.pdfhref M "abstract-types-and-interfaces"
.XS
.pdfhref L -D "abstract-types-and-interfaces" \
 -- "	\*[SN]\~\~Abstract types and interfaces"
.XE
.LP
The \f[CR]sortable\f[R] type used for demonstrating the
\f[CR]sortable_list\f[R] functionality in the \c
.pdfhref L -D "sec:oop_techniques" -A "\c" \
 -- "object\-based chapter\[cq]s"
\& example was set up as a fixed container\-like type.
It is desirable to be able to use the list machinery more flexibly i.e.,
for any type that supports the \[lq]less\-than\[rq] comparison.
This can be achieved by introducing an \f[B]abstract type\f[R]
.IP
.nf
\f[C]
\*[DataTypeTok "TYPE"]\*[NormalTok ", "]\*[DataTypeTok "ABSTRACT"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " sortable"]
\*[KeywordTok "CONTAINS"]
\*[NormalTok "   "]\*[DataTypeTok "PROCEDURE(compare)"]\*[NormalTok ", "]\*[DataTypeTok "DEFERRED"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " less_than"]
\*[NormalTok "   "]\*[CommentTok "! ... more to follow"]
\*[DataTypeTok "END TYPE"]
\f[]
.fi
.LP
with a \f[B]deferred binding\f[R].
It is not possible to create an object whose dynamic type is abstract,
or a non\-polymorphic object of abstract type.
For this reason, the deferred binding cannot represent an existing
procedure, but is characterized by an \f[B]abstract interface\f[R]:
.IP
.nf
\f[C]
\*[DataTypeTok "ABSTRACT"]\*[NormalTok " "]\*[KeywordTok "INTERFACE"]
\*[NormalTok "   "]\*[KeywordTok "PURE"]\*[NormalTok " "]\*[DataTypeTok "LOGICAL"]\*[NormalTok " "]\*[KeywordTok "FUNCTION"]\*[NormalTok " compare(s1, s2)"]
\*[NormalTok "      "]\*[KeywordTok "IMPORT"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " sortable"]
\*[NormalTok "      "]\*[DataTypeTok "CLASS(sortable)"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(in)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " s1, s2"]
\*[NormalTok "      "]\*[CommentTok "! dispatch is via the first argument"]
\*[NormalTok "   "]\*[KeywordTok "END FUNCTION"]
\*[KeywordTok "END INTERFACE"]
\f[]
.fi
.LP
The \f[CR]IMPORT\f[R] statement is required to give the interface access
to the type defined in its host.
Furthermore, an override of the structure constructor will be needed
.IP
.nf
\f[C]
\*[KeywordTok "INTERFACE"]\*[NormalTok " sortable"]
\*[NormalTok "   "]\*[DataTypeTok "PROCEDURE"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " create_sortable"]
\*[KeywordTok "END INTERFACE"]
\f[]
.fi
.LP
that permits creation of polymorphic \f[CR]sortable\f[R] objects.
The details of this will be described later (since, indeed, a devil
lurks in these details).
Note that the above combined use of abstract types and interfaces is
also known under the (non\-Fortran) term \f[B]interface class\f[R].
.PP
This framework permits the programmer to implement the following
programming technique, which is also known as \f[B]dependency
inversion\f[R] (not a Fortran term):
.IP " 1." 4
Any machinery that makes use of polymorphic \f[CR]sortable\f[R] objects
is made to only refer to the above abstractions.
For example, the definition of the \f[CR]sorted_list\f[R] type could be
adapted to read
.RS 4
.IP
.nf
\f[C]
\*[DataTypeTok "TYPE"]\*[NormalTok ", "]\*[DataTypeTok "PUBLIC"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " sorted_list"]
\*[NormalTok "   "]\*[DataTypeTok "PRIVATE"]
\*[NormalTok "   "]\*[DataTypeTok "CLASS(sortable)"]\*[NormalTok ", "]\*[DataTypeTok "ALLOCATABLE"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " data"]
\*[NormalTok "   "]\*[CommentTok "! changed to refer to abstract type"]
\*[NormalTok "   "]\*[DataTypeTok "TYPE(sorted_list)"]\*[NormalTok ", "]\*[DataTypeTok "POINTER"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " next "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " null()"]
\*[KeywordTok "CONTAINS"]
\*[NormalTok "   "]\*[DataTypeTok "FINAL"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " delete_sorted_list"]
\*[DataTypeTok "END TYPE"]
\f[]
.fi
.RE
.LP
The advantage of this is that no change to the preexisting machinery
will be needed whenever a programmer decides to add an extension type as
outlined in 2.
below.
.IP " 2." 4
For a concrete realization of a \f[CR]sortable\f[R] object, the
programmer needs to create a type extension, for example
.RS 4
.IP
.nf
\f[C]
\*[DataTypeTok "TYPE"]\*[NormalTok ", "]\*[DataTypeTok "PUBLIC"]\*[NormalTok ", "]\*[DataTypeTok "EXTENDS(sortable)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " sortable_string"]
\*[NormalTok "   "]\*[DataTypeTok "CHARACTER(len=:)"]\*[NormalTok ", "]\*[DataTypeTok "ALLOCATABLE"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " string"]
\*[KeywordTok "CONTAINS"]
\*[NormalTok "   "]\*[DataTypeTok "PROCEDURE"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " less_than "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " less_than_string"]
\*[DataTypeTok "END TYPE"]
\f[]
.fi
.RE
.LP
including an \f[I]obligatory\f[R] implementation
\f[CR]less_than_string\f[R] of an overriding TBP for the deferred
binding.
The constructor function (promised earlier, but not yet delivered) also
needs to be updated to enable creation of objects of the extended type.
.NH 1
Generic type\-bound procedures and operator overloading
.pdfhref O 1 "\*[SN]  Generic type-bound procedures and operator overloading"
.pdfhref M "generic-type-bound-procedures-and-operator-overloading"
.XS
.pdfhref L -D "generic-type-bound-procedures-and-operator-overloading" \
 -- "	\*[SN]\~\~Generic type\-bound procedures and operator overloading"
.XE
.LP
As a convenience, use of an overloading for the comparison operator
\[lq]<\[rq] can be provided by creating a \f[B]generic\f[R] type\-bound
procedure:
.IP
.nf
\f[C]
\*[DataTypeTok "TYPE"]\*[NormalTok ", "]\*[DataTypeTok "ABSTRACT"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " sortable"]
\*[KeywordTok "CONTAINS"]
\*[NormalTok "   "]\*[DataTypeTok "PROCEDURE(compare)"]\*[NormalTok ", "]\*[DataTypeTok "DEFERRED"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " less_than"]
\*[NormalTok "   "]\*[DataTypeTok "GENERIC"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " "]\*[KeywordTok "OPERATOR"]\*[NormalTok "("]\*[OperatorTok "<"]\*[NormalTok ") "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " less_than"]
\*[DataTypeTok "END TYPE"]
\f[]
.fi
.LP
which means that when a statement involving a comparison expression
.IP
.nf
\f[C]
\*[DataTypeTok "CLASS(sortable)"]\*[NormalTok ", "]\*[DataTypeTok "ALLOCATABLE"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " s1, s2"]

\*[NormalTok "s1 "]\*[KeywordTok "="]\*[NormalTok " sortable( ... )"]
\*[NormalTok "s2 "]\*[KeywordTok "="]\*[NormalTok " sortable( ... )"]

\*[KeywordTok "IF"]\*[NormalTok " ( s1 "]\*[OperatorTok "<"]\*[NormalTok " s2 ) "]\*[KeywordTok "THEN"]
\*[NormalTok "   ..."]
\*[KeywordTok "END IF"]
\f[]
.fi
.LP
is executed, the overridden type\-bound procedure bound to the first
operand will be invoked to evaluate the expression.
It is not necessary to re\-specify the \f[CR]GENERIC\f[R] clause in any
type extensions; the dispatch will automatically select the overridden
procedure.
.PP
Named generic type\-bound procedures that do not overload existing
operations can also be defined; an example for this is given in the
section \[lq]\c
.pdfhref L -D "sec:functions_with_parameters" -A "\c" \
 -- "Functions with parameters"
\&\[rq].
The rules for generic resolution work similar as for nonpolymorphic
generic procedure interfaces, with the additional restriction that
polymorphic dummy arguments that are related by inheritance cannot be
distinguished for the purpose of compile\-time resolution to a specific
procedure.
.NH 1
Completing the dependency inversion
.pdfhref O 1 "\*[SN]  Completing the dependency inversion"
.pdfhref M "completing-the-dependency-inversion"
.XS
.pdfhref L -D "completing-the-dependency-inversion" \
 -- "	\*[SN]\~\~Completing the dependency inversion"
.XE
.NH 2
Discussion of structural dependencies
.pdfhref O 2 "\*[SN]  Discussion of structural dependencies"
.pdfhref M "discussion-of-structural-dependencies"
.XS
.pdfhref L -D "discussion-of-structural-dependencies" \
 -- "		\*[SN]\~\~Discussion of structural dependencies"
.XE
.LP
When implementing the above concept, typically a separate module, say
\f[CR]mod_sortable_extensions\f[R], is created for some or all of the
extension types of \f[CR]sortable\f[R].
The motivations for this can be:
.IP \[bu] 3
avoid recompilation of any machinery that makes use of the
\f[CR]mod_sortable\f[R] module;
.IP \[bu] 3
the source code of \f[CR]mod_sortable\f[R] might not be readily
modifiable;
.IP \[bu] 3
prevent \f[CR]mod_sortable\f[R] from turning into a monster module in
case large concepts are implemented through extension types, or many
extension types are created.
.LP
The implementation of the constructor will need to use associate
\f[CR]mod_sortable_extensions\f[R] since it needs to be able to create
objects of the types defined there.
On the other hand, the interface to the constructor needs to be visible
in \f[CR]mod_sortable\f[R], since the machinery that depends on it must
be able to call it.
As a consequence, one would end up with a circular \f[CR]USE\f[R]
dependency between the two modules, which is prohibited.
.NH 2
Using submodules to break dependency cycles
.pdfhref O 2 "\*[SN]  Using submodules to break dependency cycles"
.pdfhref M "using-submodules-to-break-dependency-cycles"
.XS
.pdfhref L -D "using-submodules-to-break-dependency-cycles" \
 -- "		\*[SN]\~\~Using submodules to break dependency cycles"
.XE
.LP
To deal with such a situation (among others), the concept of
\f[B]submodule\f[R] is available.
This is a type of program unit that serves as an extension to an
existing module (or submodule), to which it has access by host
association.
Furthermore, submodules allow the programmer to separate interfaces from
implementations; the former are defined in the parent program unit
(i.e., the program unit of which the submodule is an extension), the
latter in the submodule itself.
.PP
For the constructor function, the following interface block can be
declared in \f[CR]mod_sortable\f[R]:
.IP
.nf
\f[C]
\*[KeywordTok "INTERFACE"]
\*[NormalTok "   "]\*[KeywordTok "MODULE"]\*[NormalTok " "]\*[KeywordTok "FUNCTION"]\*[NormalTok " create_sortable(init) "]\*[KeywordTok "RESULT"]\*[NormalTok "(r)"]
\*[NormalTok "      "]\*[DataTypeTok "CLASS(sortable)"]\*[NormalTok ", "]\*[DataTypeTok "ALLOCATABLE"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " r"]
\*[NormalTok "      "]\*[DataTypeTok "TYPE(initialize)"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(in)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " init"]
\*[NormalTok "   "]\*[KeywordTok "END FUNCTION"]
\*[KeywordTok "END INTERFACE"]
\f[]
.fi
.LP
The special notation \f[CR]MODULE FUNCTION\f[R] (or
\f[CR]MODULE SUBROUTINE\f[R] for a subroutine) tells the compiler that
the implementation is deferred to a submodule.
.PP
\f[B]Notes:\f[R]
.IP \[bu] 3
the above interface requires no reference to any entities contained in
\f[CR]mod_sortable_extensions\f[R];
.IP \[bu] 3
consistent with this, the variable representing the function result is
an allocatable polymorphic object of the abstract type;
.IP \[bu] 3
an \f[CR]IMPORT\f[R] statement is not obligatory in separate module
procedure interfaces, although it is permitted (compiler support
assumed!), primarily for the purpose of fine\-grain control of host
access;
.IP \[bu] 3
the type \f[CR]initialize\f[R] is, again, a renamed version of the
\f[CR]any_object\f[R] type referred to earlier.
.NH 2
Implementation of the constructor
.pdfhref O 2 "\*[SN]  Implementation of the constructor"
.pdfhref M "implementation-of-the-constructor"
.XS
.pdfhref L -D "implementation-of-the-constructor" \
 -- "		\*[SN]\~\~Implementation of the constructor"
.XE
.LP
The submodule containing the implementation then reads as follows:
.IP
.nf
\f[C]
\*[KeywordTok "SUBMODULE"]\*[NormalTok " (mod_sortable) smod_constructor"]
\*[KeywordTok "CONTAINS"]
\*[NormalTok "   "]\*[KeywordTok "MODULE PROCEDURE"]\*[NormalTok " create_sortable"]
\*[NormalTok "      "]\*[KeywordTok "USE"]\*[NormalTok " mod_sortable_extensions, "]\*[KeywordTok "ONLY"]\*[NormalTok " : sortable_string"]

\*[NormalTok "      "]\*[KeywordTok "IF"]\*[NormalTok " ( "]\*[FunctionTok "allocated"]\*[NormalTok "(init"]\*[OperatorTok "%"]\*[NormalTok "description) "]\*[OperatorTok ".AND."]\*[NormalTok " "]\*[FunctionTok "allocated"]\*[NormalTok "(init"]\*[OperatorTok "%"]\*[DataTypeTok "value"]\*[NormalTok ") ) "]\*[KeywordTok "THEN"]
\*[NormalTok "         "]\*[KeywordTok "SELECT CASE"]\*[NormalTok " (init"]\*[OperatorTok "%"]\*[NormalTok "description)"]
\*[NormalTok "         "]\*[KeywordTok "CASE"]\*[NormalTok " ("]\*[StringTok "\[aq]sortable_string\[aq]"]\*[NormalTok ")"]
\*[NormalTok "            "]\*[KeywordTok "SELECT TYPE"]\*[NormalTok " ( "]\*[DataTypeTok "value"]\*[NormalTok " "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " init"]\*[OperatorTok "%"]\*[DataTypeTok "value"]\*[NormalTok "("]\*[DecValTok "1"]\*[NormalTok ") )"]
\*[NormalTok "            "]\*[KeywordTok "TYPE IS"]\*[NormalTok " ("]\*[DataTypeTok "CHARACTER(len=*)"]\*[NormalTok ")"]
\*[NormalTok "               "]\*[KeywordTok "ALLOCATE"]\*[NormalTok "( r, source"]\*[KeywordTok "="]\*[NormalTok "sortable_string("]\*[DataTypeTok "value"]\*[NormalTok ") )"]
\*[NormalTok "            "]\*[KeywordTok "END SELECT"]
\*[NormalTok "         "]\*[KeywordTok "END SELECT"]
\*[NormalTok "      "]\*[KeywordTok "END IF"]
\*[NormalTok "   "]\*[KeywordTok "END PROCEDURE"]
\*[KeywordTok "END SUBMODULE"]
\f[]
.fi
.LP
\f[B]Notes:\f[R]
.IP \[bu] 3
The interface for the separate module procedures is omitted, since it
can be deduced from its specification in the parent module.
However, alternative syntax exists that replicates the interface (but
this is not shown here);
.IP \[bu] 3
the effect of the \f[CR]ONLY\f[R] clause is to suppress use access to
any entity of the parent program unit (which would be indirectly
established).
This is because use association overrides host association, which may
cause undesirable side effects;
.IP \[bu] 3
submodules additionally can contain specifications (before the
\f[CR]CONTAINS\f[R] statement), as well as local submodule procedures.
All these are only accessible from the submodule (and its descendant
submodules, if any);
.IP \[bu] 3
the naming scheme for a submodule always references the direct parent.
For submodules of submodules, the scheme is
\f[CR]SUBMODULE (<parent module>:<parent submodule>) <submodule_name>\f[R]
and the names of submodules of a given module must be unique.
.NH 2
Diagramming the dependencies between program units
.pdfhref O 2 "\*[SN]  Diagramming the dependencies between program units"
.pdfhref M "diagramming-the-dependencies-between-program-units"
.XS
.pdfhref L -D "diagramming-the-dependencies-between-program-units" \
 -- "		\*[SN]\~\~Diagramming the dependencies between program units"
.XE
.LP
The following diagram shows the use and host association relationships
between the modules (blue boxes), the submodule (green box), and a main
program unit (orange box) for this example:
.PDFPIC ./images/Dependency_inversion.pdf 4.8i
.QP
Dependencies between program units implementing and using an interface
class

.LP
The small triangles in the diagram refer to use (\[lq]u\[rq])
association and host (\[lq]h\[rq]) association, respectively.
The separation of the constructor\[cq]s interface from its
implementation leads to avoidance of circular \f[CR]USE\f[R] references
(the lower two \[lq]u\[rq] triangles in the diagram).
.PP
The compilation order for separate files would be:
.IP " 1." 4
\f[CR]mod_sortable\f[R]
.IP " 2." 4
\f[CR]program\f[R] and \f[CR]mod_sortable_extensions\f[R], independently
.IP " 3." 4
\f[CR]smod_constructor\f[R]
.NH 1
Performance and ease of use
.pdfhref O 1 "\*[SN]  Performance and ease of use"
.pdfhref M "performance-and-ease-of-use"
.XS
.pdfhref L -D "performance-and-ease-of-use" \
 -- "	\*[SN]\~\~Performance and ease of use"
.XE
.NH 1
Functions with parameters
.pdfhref O 1 "\*[SN]  Functions with parameters"
.pdfhref M "sec:functions_with_parameters"
.XS
.pdfhref L -D "sec:functions_with_parameters" \
 -- "	\*[SN]\~\~Functions with parameters"
.XE
.NH 2
A type definition for invocation of a general function
.pdfhref O 2 "\*[SN]  A type definition for invocation of a general function"
.pdfhref M "a-type-definition-for-invocation-of-a-general-function"
.XS
.pdfhref L -D "a-type-definition-for-invocation-of-a-general-function" \
 -- "		\*[SN]\~\~A type definition for invocation of a general function"
.XE
.LP
In scientific applications, a commonly occurring requirement is the need
to evaluate functions that depend on additional parameters, apart from
their real\-valued argument.
For example, an application might need the value of spherical Bessel
function @x \*[mp] j sub l left ( q ^ x right )@ for independently
specified integer values of @l@ and real values of @q@.
More generally, one can consider a real\-valued mapping
.PP
@\[u211C] \[u220B] x \*[mp] f sub lambda left ( x right ) fwd 100 left ( lambda \[u2208] OMEGA right )@,
.PP
where the parameter value @lambda@ can be from some arbitrary set.
This section presents a way for handling this programmatically, using
the object\-oriented features of Fortran.
We start with the outline for a type definition of sufficient
generality:
.IP
.nf
\f[C]
\*[DataTypeTok "TYPE"]\*[NormalTok ", "]\*[DataTypeTok "PUBLIC"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " pfunc_type"]
\*[NormalTok "   "]\*[DataTypeTok "PRIVATE"]
\*[NormalTok "   "]\*[DataTypeTok "PROCEDURE(pfunc)"]\*[NormalTok ", "]\*[DataTypeTok "POINTER"]\*[NormalTok ", "]\*[DataTypeTok "NOPASS"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " fp "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " null()"]
\*[NormalTok "   : "]\*[CommentTok "! shown later"]
\*[NormalTok "   "]\*[DataTypeTok "CLASS(*)"]\*[NormalTok ", "]\*[DataTypeTok "ALLOCATABLE"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " param"]
\*[KeywordTok "CONTAINS"]
\*[NormalTok "   : "]\*[CommentTok "! shown later"]
\*[DataTypeTok "END type"]\*[NormalTok " pfunc_type"]

\*[DataTypeTok "ABSTRACT"]\*[NormalTok " "]\*[KeywordTok "INTERFACE"]
\*[NormalTok "   "]\*[KeywordTok "PURE"]\*[NormalTok " "]\*[DataTypeTok "REAL"]\*[NormalTok " "]\*[KeywordTok "FUNCTION"]\*[NormalTok " pfunc(x, param)"]
\*[NormalTok "      "]\*[DataTypeTok "REAL"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(in)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " x"]
\*[NormalTok "      "]\*[DataTypeTok "CLASS(*)"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(in)"]\*[NormalTok ", "]\*[DataTypeTok "OPTIONAL"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " param"]
\*[NormalTok "   "]\*[KeywordTok "END FUNCTION"]\*[NormalTok " pfunc"]
\*[KeywordTok "END INTERFACE"]
\f[]
.fi
.LP
It supplies
.IP \[bu] 3
a \f[B]procedure pointer\f[R] component with an abstract interface that
reflects the above mapping;
.IP \[bu] 3
an unlimited polymorphic parameter component, to keep all things in one
place.
.LP
Notionally, one could invoke a properly set up \f[CR]pfunc_type\f[R]
object through
.IP
.nf
\f[C]
\*[DataTypeTok "TYPE(pfunc_type)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " pfunc_obj"]
\*[DataTypeTok "REAL"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " x"]

\*[NormalTok "pfunc_obj "]\*[KeywordTok "="]\*[NormalTok " pfunc_type(psin, "]\*[DecValTok "2"]\*[NormalTok ")"]
\*[CommentTok "! definitions of procedure and data object discussed further below"]
\*[NormalTok "x "]\*[KeywordTok "="]\*[NormalTok " ..."]

\*[FunctionTok "WRITE(*"]\*[NormalTok ","]\*[FunctionTok "*)"]\*[NormalTok " "]\*[StringTok "\[aq]Function value is \[aq]"]\*[NormalTok ", pfunc_obj"]\*[OperatorTok "%"]\*[NormalTok "fp(x, pfunc_obj"]\*[OperatorTok "%"]\*[NormalTok "param)"]
\f[]
.fi
.LP
Use of a procedure pointer reflects the fact that each
\f[CR]pfunc_type\f[R] object will want to associate its individual
target function; this is sometimes also referred to as an
\f[B]object\-bound procedure\f[R].
The \f[CR]NOPASS\f[R] attribute in the type definition is needed because
otherwise (analogous to what we saw for the earlier type\-bound
procedure examples), the object through which the invocation is done
would be obliged to appear as a first argument in the abstract interface
\f[CR]pfunc\f[R]; this would constitute an additional imposition on the
implementation of the supplied functions.
On the other hand, the invocation needs to explicitly specify the
\f[CR]param\f[R] component, making it a bit unwieldy; the use of
\f[CR]pfunc_type\f[R] objects will be simplified as we go on.
.NH 2
Performance issues arising from object\-oriented programming
.pdfhref O 2 "\*[SN]  Performance issues arising from object-oriented programming"
.pdfhref M "performance-issues-arising-from-object-oriented-programming"
.XS
.pdfhref L -D "performance-issues-arising-from-object-oriented-programming" \
 -- "		\*[SN]\~\~Performance issues arising from object\-oriented programming"
.XE
.LP
Let us look at a target function implementation, in form of a trivial
example @sin left ( lambda x right )@:
.IP
.nf
\f[C]
\*[KeywordTok "PURE"]\*[NormalTok " "]\*[DataTypeTok "REAL"]\*[NormalTok " "]\*[KeywordTok "FUNCTION"]\*[NormalTok " psin(x, param)"]
\*[NormalTok "   "]\*[DataTypeTok "REAL"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(in)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " x"]
\*[NormalTok "   "]\*[DataTypeTok "CLASS(*)"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(in)"]\*[NormalTok ", "]\*[DataTypeTok "OPTIONAL"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " param"]
\*[NormalTok "   "]\*[DataTypeTok "REAL"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " factor"]
\*[NormalTok "   factor "]\*[KeywordTok "="]\*[NormalTok " "]\*[FloatTok "1."]
\*[NormalTok "   "]\*[KeywordTok "IF"]\*[NormalTok " ( "]\*[FunctionTok "present"]\*[NormalTok "(param) ) "]\*[KeywordTok "THEN"]
\*[NormalTok "      "]\*[KeywordTok "SELECT TYPE"]\*[NormalTok " ( param )"]
\*[NormalTok "      "]\*[KeywordTok "TYPE IS"]\*[NormalTok " ("]\*[DataTypeTok "REAL"]\*[NormalTok ")"]
\*[NormalTok "         factor "]\*[KeywordTok "="]\*[NormalTok " param"]
\*[NormalTok "      "]\*[KeywordTok "TYPE IS"]\*[NormalTok " ("]\*[DataTypeTok "INTEGER"]\*[NormalTok ")"]
\*[NormalTok "         factor "]\*[KeywordTok "="]\*[NormalTok " "]\*[DataTypeTok "real(param)"]
\*[NormalTok "      "]\*[KeywordTok "END SELECT"]
\*[NormalTok "   "]\*[KeywordTok "END IF"]
\*[NormalTok "   psin "]\*[KeywordTok "="]\*[NormalTok " "]\*[BuiltInTok "sin"]\*[NormalTok "(factor"]\*[KeywordTok "*"]\*[NormalTok "x)"]
\*[KeywordTok "END FUNCTION"]\*[NormalTok " psin"]
\f[]
.fi
.LP
Given that an application is likely to request a large number of
function values, the following effects would ensue once for each
invocation:
.IP \[bu] 3
function call overhead, and
.IP \[bu] 3
overhead of run\-time type resolution.
.LP
The resulting performance impact is typical for object\-oriented designs
that operate in multitudes on small objects.
Making use of an array\-based version of the function
.IP
.nf
\f[C]
\*[KeywordTok "PURE"]\*[NormalTok " "]\*[KeywordTok "FUNCTION"]\*[NormalTok " psin_array(x, param) "]\*[KeywordTok "RESULT"]\*[NormalTok "(r)"]
\*[NormalTok "   "]\*[DataTypeTok "REAL"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(in)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " x(:)"]
\*[NormalTok "   "]\*[DataTypeTok "REAL"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " r("]\*[FunctionTok "size"]\*[NormalTok "(x))"]
\*[NormalTok "   "]\*[DataTypeTok "CLASS(*)"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(in)"]\*[NormalTok ", "]\*[DataTypeTok "OPTIONAL"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " param"]
\*[NormalTok "   "]\*[DataTypeTok "REAL"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " factor"]
\*[NormalTok "   factor "]\*[KeywordTok "="]\*[NormalTok " "]\*[FloatTok "1."]
\*[NormalTok "   "]\*[KeywordTok "IF"]\*[NormalTok " ( "]\*[FunctionTok "present"]\*[NormalTok "(param) ) "]\*[KeywordTok "THEN"]
\*[NormalTok "      "]\*[KeywordTok "SELECT TYPE"]\*[NormalTok " ( param )"]
\*[NormalTok "      "]\*[KeywordTok "TYPE IS"]\*[NormalTok " ("]\*[DataTypeTok "REAL"]\*[NormalTok ")"]
\*[NormalTok "         factor "]\*[KeywordTok "="]\*[NormalTok " param"]
\*[NormalTok "      "]\*[KeywordTok "TYPE IS"]\*[NormalTok " ("]\*[DataTypeTok "INTEGER"]\*[NormalTok ")"]
\*[NormalTok "         factor "]\*[KeywordTok "="]\*[NormalTok " "]\*[DataTypeTok "real(param)"]
\*[NormalTok "      "]\*[KeywordTok "END SELECT"]
\*[NormalTok "   "]\*[KeywordTok "END IF"]
\*[NormalTok "   r "]\*[KeywordTok "="]\*[NormalTok " "]\*[BuiltInTok "sin"]\*[NormalTok "(factor"]\*[KeywordTok "*"]\*[NormalTok "x)  "]\*[CommentTok "! kernel"]
\*[KeywordTok "END FUNCTION"]\*[NormalTok " psin_array"]
\f[]
.fi
.LP
is desirable, since the overheads specified above only arise
\f[I]once\f[R], and the actual calculational code (marked
\[lq]kernel\[rq] in the above box) is amenable to array\-related
compiler optimizations (the specifics of which depend on both hardware
architecture and working set size).
.NH 2
Completing the function type definition
.pdfhref O 2 "\*[SN]  Completing the function type definition"
.pdfhref M "completing-the-function-type-definition"
.XS
.pdfhref L -D "completing-the-function-type-definition" \
 -- "		\*[SN]\~\~Completing the function type definition"
.XE
.LP
The aim now is to proceed to a framework that permits to use both the
scalar and the array versions in a uniform way, thereby making life for
the clients that use the framework easy, while enabling performance
where it is needed.
.PP
The full definition of \f[CR]pfunc_type\f[R], including its referenced
abstract interfaces, reads
.IP
.nf
\f[C]
\*[DataTypeTok "TYPE"]\*[NormalTok ", "]\*[DataTypeTok "PUBLIC"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " pfunc_type"]
\*[NormalTok "   "]\*[DataTypeTok "PRIVATE"]
\*[NormalTok "   "]\*[DataTypeTok "PROCEDURE(pfunc)"]\*[NormalTok ", "]\*[DataTypeTok "POINTER"]\*[NormalTok ", "]\*[DataTypeTok "NOPASS"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " fp "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " null()"]
\*[NormalTok "   "]\*[DataTypeTok "PROCEDURE(pfunc_array)"]\*[NormalTok ", "]\*[DataTypeTok "POINTER"]\*[NormalTok ", "]\*[DataTypeTok "NOPASS"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " fp_array "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " null()"]
\*[NormalTok "   "]\*[DataTypeTok "CLASS(*)"]\*[NormalTok ", "]\*[DataTypeTok "ALLOCATABLE"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " param"]
\*[KeywordTok "CONTAINS"]
\*[NormalTok "   "]\*[DataTypeTok "PROCEDURE"]\*[NormalTok ", "]\*[DataTypeTok "PASS"]\*[NormalTok ", "]\*[DataTypeTok "PRIVATE"]\*[NormalTok ", "]\*[DataTypeTok "NON_OVERRIDABLE"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " f_scalar, f_array"]
\*[NormalTok "   "]\*[DataTypeTok "GENERIC"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " f "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " f_scalar, f_array"]
\*[DataTypeTok "END type"]\*[NormalTok " pfunc_type"]

\*[DataTypeTok "ABSTRACT"]\*[NormalTok " "]\*[KeywordTok "INTERFACE"]
\*[NormalTok "   "]\*[KeywordTok "PURE"]\*[NormalTok " "]\*[DataTypeTok "REAL"]\*[NormalTok " "]\*[KeywordTok "FUNCTION"]\*[NormalTok " pfunc(x, param)"]
\*[NormalTok "      "]\*[DataTypeTok "REAL"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(in)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " x"]
\*[NormalTok "      "]\*[DataTypeTok "CLASS(*)"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(in)"]\*[NormalTok ", "]\*[DataTypeTok "OPTIONAL"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " param"]
\*[NormalTok "   "]\*[KeywordTok "END FUNCTION"]\*[NormalTok " pfunc"]
\*[NormalTok "   "]\*[KeywordTok "PURE"]\*[NormalTok " "]\*[KeywordTok "FUNCTION"]\*[NormalTok " pfunc_array(x, param) "]\*[KeywordTok "RESULT"]\*[NormalTok "(r)"]
\*[NormalTok "      "]\*[DataTypeTok "REAL"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(in)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " x(:)"]
\*[NormalTok "      "]\*[DataTypeTok "REAL"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " r("]\*[FunctionTok "size"]\*[NormalTok "(x))"]
\*[NormalTok "      "]\*[DataTypeTok "CLASS(*)"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(in)"]\*[NormalTok ", "]\*[DataTypeTok "OPTIONAL"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " param"]
\*[NormalTok "   "]\*[KeywordTok "END FUNCTION"]\*[NormalTok " pfunc_array"]
\*[KeywordTok "END INTERFACE"]
\f[]
.fi
.LP
Because we now have two procedure pointers in the type (only one of
which is used in each given object), it is advantageous to provide a
generic type\-bound procedure \f[CR]f\f[R] as a front end for ease of
use.
The specifics \f[CR]f_scalar\f[R] and \f[CR]f_array\f[R] for this read
.IP
.nf
\f[C]
\*[DataTypeTok "REAL"]\*[NormalTok " "]\*[KeywordTok "FUNCTION"]\*[NormalTok " f_scalar(this, x)"]
\*[NormalTok "   "]\*[DataTypeTok "CLASS(pfunc_type)"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(in)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " this"]
\*[NormalTok "   "]\*[DataTypeTok "REAL"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(in)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " x"]

\*[NormalTok "   "]\*[KeywordTok "IF"]\*[NormalTok " ( "]\*[FunctionTok "associated"]\*[NormalTok "(this"]\*[OperatorTok "%"]\*[NormalTok "fp) ) "]\*[KeywordTok "THEN"]
\*[NormalTok "      f_scalar "]\*[KeywordTok "="]\*[NormalTok " this"]\*[OperatorTok "%"]\*[NormalTok "fp(x, this"]\*[OperatorTok "%"]\*[NormalTok "param)"]
\*[NormalTok "   "]\*[KeywordTok "ELSE"]\*[NormalTok " "]\*[KeywordTok "IF"]\*[NormalTok " ( "]\*[FunctionTok "associated"]\*[NormalTok "(this"]\*[OperatorTok "%"]\*[NormalTok "fp_array) ) "]\*[KeywordTok "THEN"]
\*[NormalTok "      "]\*[KeywordTok "ASSOCIATE"]\*[NormalTok " ( f_array "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " this"]\*[OperatorTok "%"]\*[NormalTok "fp_array("]\*[KeywordTok "["]\*[NormalTok "x"]\*[KeywordTok "]"]\*[NormalTok ", this"]\*[OperatorTok "%"]\*[NormalTok "param) )"]
\*[NormalTok "         f_scalar "]\*[KeywordTok "="]\*[NormalTok " f_array("]\*[DecValTok "1"]\*[NormalTok ")"]
\*[NormalTok "      "]\*[KeywordTok "END ASSOCIATE"]
\*[NormalTok "   "]\*[KeywordTok "ELSE"]
\*[NormalTok "      ERROR "]\*[KeywordTok "STOP"]\*[NormalTok " "]\*[StringTok "\[aq]pfunc_type callback: uninitialized object\[aq]"]
\*[NormalTok "   "]\*[KeywordTok "END IF"]
\*[KeywordTok "END FUNCTION"]\*[NormalTok " f_scalar"]
\*[KeywordTok "FUNCTION"]\*[NormalTok " f_array(this, x) "]\*[KeywordTok "RESULT"]\*[NormalTok "(r)"]
\*[NormalTok "   "]\*[DataTypeTok "CLASS(pfunc_type)"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(in)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " this"]
\*[NormalTok "   "]\*[DataTypeTok "REAL"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(in)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " x(:)"]
\*[NormalTok "   "]\*[DataTypeTok "REAL"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " r("]\*[FunctionTok "size"]\*[NormalTok "(x))"]

\*[NormalTok "   "]\*[CommentTok "! Note that support for the scalar version is omitted here, since"]
\*[NormalTok "   "]\*[CommentTok "! the procedure call overhead, including type resolution, would"]
\*[NormalTok "   "]\*[CommentTok "! significantly impact performance."]
\*[NormalTok "   "]\*[KeywordTok "IF"]\*[NormalTok " ( "]\*[FunctionTok "associated"]\*[NormalTok "(this"]\*[OperatorTok "%"]\*[NormalTok "fp_array) ) "]\*[KeywordTok "THEN"]
\*[NormalTok "      r "]\*[KeywordTok "="]\*[NormalTok " this"]\*[OperatorTok "%"]\*[NormalTok "fp_array(x, this"]\*[OperatorTok "%"]\*[NormalTok "param)"]
\*[NormalTok "   "]\*[KeywordTok "ELSE"]
\*[NormalTok "      ERROR "]\*[KeywordTok "STOP"]\*[NormalTok " "]\*[StringTok "\[aq]pfunc_type callback: uninitialized object\[aq]"]
\*[NormalTok "   "]\*[KeywordTok "END IF"]
\*[KeywordTok "END FUNCTION"]\*[NormalTok " f_array"]
\f[]
.fi
.LP
The only way to invoke one of these (in a use association context) is
via the generic name, since the specific type\-bound procedures have the
\f[CR]PRIVATE\f[R] attribute; note that \f[CR]pfunc_type\f[R] is not
designed for being extended.
Disambiguation is by rank of \f[CR]x\f[R].
.PP
The structure constructor for the type is overloaded
.IP
.nf
\f[C]
\*[KeywordTok "INTERFACE"]\*[NormalTok " pfunc_type"]
\*[NormalTok "   "]\*[KeywordTok "MODULE PROCEDURE"]\*[NormalTok " create_pfunc_type"]
\*[NormalTok "   "]\*[KeywordTok "MODULE PROCEDURE"]\*[NormalTok " create_pfunc_type_array"]
\*[KeywordTok "END INTERFACE"]\*[NormalTok " pfunc_type"]
\f[]
.fi
.LP
with the following specific functions:
.IP
.nf
\f[C]
\*[DataTypeTok "TYPE(pfunc_type)"]\*[NormalTok " "]\*[KeywordTok "FUNCTION"]\*[NormalTok " create_pfunc_type(fp, param)"]
\*[NormalTok "   "]\*[DataTypeTok "PROCEDURE(pfunc)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " fp"]
\*[NormalTok "   "]\*[DataTypeTok "CLASS(*)"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(in)"]\*[NormalTok ", "]\*[DataTypeTok "OPTIONAL"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " param"]
\*[NormalTok "   create_pfunc_type"]\*[OperatorTok "%"]\*[NormalTok "fp "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " fp"]
\*[NormalTok "   "]\*[KeywordTok "IF"]\*[NormalTok " ( "]\*[FunctionTok "present"]\*[NormalTok "(param) ) "]\*[KeywordTok "THEN"]
\*[NormalTok "      "]\*[KeywordTok "ALLOCATE"]\*[NormalTok "(create_pfunc_type"]\*[OperatorTok "%"]\*[NormalTok "param, source"]\*[KeywordTok "="]\*[NormalTok "param)"]
\*[NormalTok "   "]\*[KeywordTok "END IF"]
\*[KeywordTok "END FUNCTION"]\*[NormalTok " create_pfunc_type"]
\*[DataTypeTok "TYPE(pfunc_type)"]\*[NormalTok " "]\*[KeywordTok "FUNCTION"]\*[NormalTok " create_pfunc_type_array(fp_array, param)"]
\*[NormalTok "   "]\*[DataTypeTok "PROCEDURE(pfunc_array)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " fp_array"]
\*[NormalTok "   "]\*[DataTypeTok "CLASS(*)"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(in)"]\*[NormalTok ", "]\*[DataTypeTok "OPTIONAL"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " param"]
\*[NormalTok "   create_pfunc_type_array"]\*[OperatorTok "%"]\*[NormalTok "fp_array "]\*[KeywordTok "="]\*[OperatorTok ">"]\*[NormalTok " fp_array"]
\*[NormalTok "   "]\*[KeywordTok "IF"]\*[NormalTok " ( "]\*[FunctionTok "present"]\*[NormalTok "(param) ) "]\*[KeywordTok "THEN"]
\*[NormalTok "      "]\*[KeywordTok "ALLOCATE"]\*[NormalTok "(create_pfunc_type_array"]\*[OperatorTok "%"]\*[NormalTok "param, source"]\*[KeywordTok "="]\*[NormalTok "param)"]
\*[NormalTok "   "]\*[KeywordTok "END IF"]
\*[KeywordTok "END FUNCTION"]\*[NormalTok " create_pfunc_type_array"]
\f[]
.fi
.LP
Disambiguation is possible due to the sufficiently different interfaces
of the procedure arguments.
.NH 2
Using the function type
.pdfhref O 2 "\*[SN]  Using the function type"
.pdfhref M "using-the-function-type"
.XS
.pdfhref L -D "using-the-function-type" \
 -- "		\*[SN]\~\~Using the function type"
.XE
.LP
With the already\-shown implementations for the target functions
\f[CR]psin\f[R] and \f[CR]psin_array\f[R], using this framework is
illustrated by the following:
.IP
.nf
\f[C]
\*[DataTypeTok "TYPE(pfunc_type)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " pfunc_obj"]
\*[DataTypeTok "REAL"]\*[NormalTok ", "]\*[DataTypeTok "PARAMETER"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " piby4 "]\*[KeywordTok "="]\*[NormalTok " "]\*[BuiltInTok "atan"]\*[NormalTok "("]\*[FloatTok "1.0"]\*[NormalTok "), "]\*[KeywordTok "&"]
\*[NormalTok "   piby4_arr("]\*[DecValTok "4"]\*[NormalTok ") "]\*[KeywordTok "="]\*[NormalTok " "]\*[KeywordTok "["]\*[NormalTok " piby4, "]\*[FloatTok "2."]\*[KeywordTok "*"]\*[NormalTok "piby4, "]\*[FloatTok "3."]\*[KeywordTok "*"]\*[NormalTok "piby4, "]\*[FloatTok "4."]\*[KeywordTok "*"]\*[NormalTok "piby4 "]\*[KeywordTok "]"]

\*[NormalTok "pfunc_obj "]\*[KeywordTok "="]\*[NormalTok " pfunc_type(psin, "]\*[FloatTok "2."]\*[NormalTok ")"]
\*[FunctionTok "WRITE(*"]\*[NormalTok ","]\*[FunctionTok "*)"]\*[NormalTok " pfunc_obj"]\*[OperatorTok "%"]\*[NormalTok "f(piby4)"]

\*[NormalTok "pfunc_obj "]\*[KeywordTok "="]\*[NormalTok " pfunc_type(psin)"]
\*[FunctionTok "WRITE(*"]\*[NormalTok ","]\*[FunctionTok "*)"]\*[NormalTok " pfunc_obj"]\*[OperatorTok "%"]\*[NormalTok "f(piby4)"]

\*[NormalTok "pfunc_obj "]\*[KeywordTok "="]\*[NormalTok " pfunc_type(psin_array, "]\*[FloatTok "2."]\*[NormalTok ")"]
\*[FunctionTok "WRITE(*"]\*[NormalTok ","]\*[FunctionTok "*)"]\*[NormalTok " pfunc_obj"]\*[OperatorTok "%"]\*[NormalTok "f(piby4_arr)"]
\f[]
.fi
.LP
Omitting a \f[CR]param\f[R] in a constructor is fine, as long as the
target functions cater for the dummy argument\[cq]s non\-presence.
.PP
\f[I]Hint:\f[R] The framework\[cq]s implementation makes use of the fact
that an unallocated actual argument associated with an
\f[CR]OPTIONAL\f[R] dummy argument is considered not present.
Once conditional expressions are implemented in compilers, the code will
be appropriately reworked, since use of this feature is recommended
against.
.NH 1
Arrays of structures versus structures of arrays
.pdfhref O 1 "\*[SN]  Arrays of structures versus structures of arrays"
.pdfhref M "arrays-of-structures-versus-structures-of-arrays"
.XS
.pdfhref L -D "arrays-of-structures-versus-structures-of-arrays" \
 -- "	\*[SN]\~\~Arrays of structures versus structures of arrays"
.XE
.LP
Returning to our earlier example type body, the next idea would be to
simulate the dynamics of a large ensemble of bodies.
A procedure
.IP
.nf
\f[C]
\*[KeywordTok "SUBROUTINE"]\*[NormalTok " propagate(bodies, delta_t, force_field)"]
\*[NormalTok "   "]\*[DataTypeTok "TYPE(body)"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(inout)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " bodies(:)"]
\*[NormalTok "   "]\*[DataTypeTok "REAL"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(in)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " delta_t"]
\*[NormalTok "   "]\*[DataTypeTok "TYPE(field_type)"]\*[NormalTok ", "]\*[DataTypeTok "INTENT(in)"]\*[NormalTok " "]\*[DataTypeTok "::"]\*[NormalTok " force_field"]
\*[NormalTok "   :"]
\*[KeywordTok "END SUBROUTINE"]
\f[]
.fi
.LP
might be supplied that modifies the components of all ensemble members,
for example as follows:
.IP \[bu] 3
\f[CR]%pos\f[R] @->@ \f[CR]%pos + delta_t * %vel\f[R]
.IP \[bu] 3
\f[CR]%vel\f[R] @->@ \f[CR]%vel + delta_t * force / %mass\f[R]
.LP
where \f[CR]force\f[R] results from evaluating \f[CR]force_field\f[R] at
the position of the ensemble member.
.NH 1
Comments on further language features
.pdfhref O 1 "\*[SN]  Comments on further language features"
.pdfhref M "comments-on-further-language-features"
.XS
.pdfhref L -D "comments-on-further-language-features" \
 -- "	\*[SN]\~\~Comments on further language features"
.XE
.NH 2
Variations on the passed object
.pdfhref O 2 "\*[SN]  Variations on the passed object"
.pdfhref M "variations-on-the-passed-object"
.XS
.pdfhref L -D "variations-on-the-passed-object" \
 -- "		\*[SN]\~\~Variations on the passed object"
.XE
.LP
All examples for type\-bound procedures given up to now have the
property that the invoking object itself is passed as the first argument
to the bound procedure.
However, this default behaviour can be modified by the programmer
.IP \[bu] 3
either declaring the binding with a \f[CR]PASS\f[R] attribute that
references the specific (and of course appropriately declared) procedure
argument the object of the bound type should be passed to,
.IP \[bu] 3
or declaring the binding with a \f[CR]NOPASS\f[R] attribute, in which
case the object is not (implicitly) passed to the procedure at all in a
TBP invocation.
.bp
.TC
.pdfsync
